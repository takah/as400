# AS400/IBM i チュートリアル - Web系エンジニア向け実践ガイド

**著者**: Manus AI  
**対象読者**: ITエンジニア経験25年程度、Web系・Open系技術に詳しい方  
**最終更新**: 2025年6月28日

---

## はじめに

このチュートリアルは、Web系やOpen系の技術に精通したITエンジニアの方が、AS400（現在のIBM i）を効率的に学習できるよう設計されています。25年のエンジニア経験をお持ちの方であれば、既存の知識を活用しながら、AS400の独特な世界を理解していただけるでしょう。

AS400は1988年の登場以来、企業の基幹システムを支え続けてきた堅牢なプラットフォームです。クラウドやマイクロサービスが主流となった現代においても、多くの企業がAS400上で重要なビジネスプロセスを運用しています。このチュートリアルでは、そんなAS400の世界への扉を開き、実践的なスキルを身につけていただくことを目指します。

---

# 第1部：基礎知識編

## 第1章：AS400/IBM iとは何か

### 1.1 AS400の歴史と発展

AS400（Application System/400）は、1988年6月21日にIBMによって発表されたミッドレンジコンピュータシステムです[1]。この発表は、コンピュータ業界において画期的な出来事でした。なぜなら、AS400は単なるハードウェアではなく、ハードウェア、オペレーティングシステム、データベース、開発環境、そしてアプリケーションが統合された「統合システム」として設計されたからです。

1980年代後半は、コンピュータ業界が大きな変革期を迎えていた時代でした。メインフレームが企業の中核を担う一方で、パーソナルコンピュータの普及により、中小企業でもコンピュータを活用したいというニーズが高まっていました。しかし、メインフレームは高価で複雑すぎ、パーソナルコンピュータでは企業の基幹業務を支えるには力不足でした。

このギャップを埋めるために開発されたのがAS400です。IBMは、中小企業でも導入可能な価格帯でありながら、メインフレーム並みの信頼性と性能を提供するシステムを目指しました。AS400の設計思想は「ビジネスのためのシステム」であり、IT専門家でなくても使いやすく、かつ企業の成長に合わせて拡張できるシステムとして構想されました[2]。

AS400の名称は、その後の技術進歩とともに何度か変更されています。1994年にはAS/400 Advanced Seriesとなり、2000年にはeServer iSeries、2006年にはSystem i、そして2008年からは現在のIBM i（アイ・ビー・エム アイ）という名称になっています[3]。これらの名称変更は単なるマーケティング上の理由ではなく、システムの進化と機能拡張を反映したものです。

特に重要な転換点は、2008年のIBM iへの名称変更でした。この時期から、IBMはAS400を単なるレガシーシステムではなく、現代的なビジネス要件に対応できるプラットフォームとして位置づけ直しました。IBM iは、従来のAS400の堅牢性と信頼性を維持しながら、Webサービス、SOA（Service-Oriented Architecture）、クラウド連携などの現代的な技術要素を取り込んでいます。

### 1.2 現在のIBM iとの関係

現在のIBM iは、AS400の直系の後継システムです。しかし、1988年の初代AS400と現在のIBM iを比較すると、その進化の度合いは驚くべきものがあります。ハードウェアアーキテクチャはPOWERプロセッサベースに移行し、オペレーティングシステムも大幅に機能拡張されています。

IBM iの最新バージョンは、2025年4月に発表されたIBM i 7.6です[4]。このバージョンでは、セキュリティ機能の強化、アプリケーション開発環境の改善、システム管理機能の向上が図られています。特に注目すべきは、多要素認証への対応やNavigator for iの全面刷新など、現代的なIT要件に対応した機能が追加されていることです。

IBM iの特徴的な点は、下位互換性の維持です。1988年に作成されたAS400のプログラムが、現在のIBM i 7.6でもそのまま動作します。これは、企業にとって非常に重要な特徴です。長年にわたって蓄積されたビジネスロジックやデータを、システム更新のたびに作り直す必要がないからです。

Web系エンジニアの方には、この下位互換性の概念は少し馴染みがないかもしれません。Web技術の世界では、フレームワークやライブラリのバージョンアップに伴い、既存のコードを修正する必要があることが頻繁にあります。しかし、IBM iの世界では、30年以上前に書かれたプログラムが現在でも動作し続けているのです。

この下位互換性は、IBM iの設計思想である「オブジェクト指向アーキテクチャ」によって実現されています。IBM iでは、プログラム、データファイル、ユーザープロファイルなど、システム上のすべての要素が「オブジェクト」として管理されています。これらのオブジェクトは、ハードウェアやオペレーティングシステムの詳細から抽象化されており、下位レイヤーの変更が上位レイヤーに影響を与えないよう設計されています。

### 1.3 Web系システムとの違い

Web系エンジニアの方がAS400/IBM iを学習する際に最初に戸惑うのは、システムアーキテクチャの根本的な違いです。Web系システムでは、一般的に以下のような分散アーキテクチャが採用されています。

- **フロントエンド**: HTML、CSS、JavaScript（React、Vue.js、Angularなど）
- **バックエンド**: Node.js、Python、Java、PHP、Ruby on Railsなど
- **データベース**: MySQL、PostgreSQL、MongoDB、Redisなど
- **インフラ**: AWS、Azure、GCP、Dockerコンテナなど

これらの技術要素は、それぞれ独立したコンポーネントとして開発・運用され、API経由で連携します。この分散アーキテクチャの利点は、各コンポーネントを独立してスケールできることや、技術選択の自由度が高いことです。

一方、IBM iは「統合システム」として設計されています。ハードウェア、オペレーティングシステム、データベース（DB2 for i）、開発環境、実行環境がすべて一体化されており、これらを分離することはできません。この統合アーキテクチャの利点は、システム全体の最適化が図られていることや、運用管理が簡素化されることです。

具体的な違いを表で比較してみましょう。

| 項目 | Web系システム | IBM i |
|------|---------------|-------|
| アーキテクチャ | 分散型（マイクロサービス） | 統合型（モノリシック） |
| データベース | 外部DB（MySQL、PostgreSQLなど） | 統合DB（DB2 for i） |
| 開発言語 | 多様（JavaScript、Python、Javaなど） | 主にRPG、CL、SQL |
| 開発環境 | 多様（VS Code、IntelliJ、Eclipseなど） | 主に5250端末、RDi |
| デプロイメント | CI/CD、コンテナ、クラウド | コンパイル、ライブラリ配置 |
| スケーリング | 水平スケール（サーバー追加） | 垂直スケール（ハードウェア強化） |
| 運用監視 | 複数ツール（Prometheus、Grafanaなど） | 統合監視（Navigator for i） |

この違いを理解することは重要ですが、どちらが優れているかという問題ではありません。Web系システムは変化の激しいビジネス要件に柔軟に対応できる一方で、IBM iは長期間にわたって安定したサービスを提供できます。企業の基幹システムでは、この安定性が何よりも重要視されるのです。

### 1.4 なぜ今でも使われているのか

2025年現在、クラウドネイティブやマイクロサービスが主流となった時代において、なぜAS400/IBM iが今でも多くの企業で使われ続けているのでしょうか。この疑問に答えるためには、IBM iの持つ独特な価値を理解する必要があります。

**極めて高い信頼性と可用性**

IBM iの最大の特徴は、その信頼性の高さです。IBM iシステムの平均稼働率は99.9%を超えており、一部のシステムでは99.99%以上の稼働率を実現しています[5]。これは、年間のダウンタイムが1時間未満ということを意味します。

この高い信頼性は、ハードウェアとソフトウェアの統合設計によって実現されています。IBM iでは、メモリ保護、プロセス分離、自動エラー回復などの機能がオペレーティングシステムレベルで実装されており、アプリケーションの不具合がシステム全体に影響を与えることを防いでいます。

Web系システムでは、高可用性を実現するために複数のサーバーを冗長化し、ロードバランサーやオートスケーリングなどの仕組みを構築する必要があります。しかし、IBM iでは単一のシステムで高い可用性を実現できるため、システム構成がシンプルになり、運用コストを削減できます。

**統合されたセキュリティモデル**

IBM iのセキュリティモデルは、オペレーティングシステムレベルで実装されており、非常に堅牢です。すべてのオブジェクト（プログラム、データファイル、ユーザープロファイルなど）に対して、きめ細かい権限制御が可能です。

また、IBM iでは「セキュリティ・バイ・デザイン」の思想が貫かれており、デフォルトで安全な設定になっています。Web系システムでは、開発者がセキュリティ対策を意識して実装する必要がありますが、IBM iでは多くのセキュリティ機能が自動的に適用されます。

**優れたパフォーマンス**

IBM iでは、アプリケーションサーバーとデータベースサーバーが一体化されているため、ネットワーク通信のオーバーヘッドがありません。これにより、大量のデータを処理するバッチ処理や、リアルタイム性が要求されるトランザクション処理において、優れたパフォーマンスを発揮します。

実際に、AS400からオープン系システムに移行した企業の中には、パフォーマンスの低下に悩まされるケースが少なくありません[6]。特に、大量のデータを扱う基幹業務では、IBM iの統合アーキテクチャの利点が顕著に現れます。

**長期間の安定運用**

IBM iシステムの中には、20年以上にわたって安定稼働を続けているものが数多くあります。これは、ハードウェアの信頼性だけでなく、ソフトウェアの成熟度の高さを示しています。

企業の基幹システムでは、「動いているシステムには手を加えない」という原則があります。IBM iは、この原則を満たすシステムとして、多くの企業に信頼されています。

**総所有コスト（TCO）の低さ**

初期導入コストだけを見ると、IBM iはオープン系システムよりも高額に見えるかもしれません。しかし、長期間の運用を考慮した総所有コスト（TCO）で比較すると、IBM iの方が安価になるケースが多いのです。

これは、以下の要因によるものです。

- システム管理者の人数が少なくて済む
- ハードウェア障害の発生頻度が低い
- ソフトウェアのバグが少ない
- セキュリティインシデントの発生リスクが低い
- 長期間の安定運用が可能

### 1.5 2025年問題と将来性

AS400/IBM iを取り巻く環境で最も深刻な課題は、いわゆる「2025年問題」です[7]。これは、AS400に精通した技術者の高齢化と退職により、システムの維持管理が困難になるという問題です。

**技術者不足の現状**

AS400が登場した1988年から37年が経過し、当時からAS400に携わってきた技術者の多くが定年退職の時期を迎えています。一方で、新しい技術者の育成は十分に進んでおらず、AS400技術者の不足が深刻化しています。

この問題は日本だけでなく、世界的な傾向です。若い技術者は、クラウドやAI、モバイルアプリ開発などの新しい技術分野に関心を向ける傾向があり、AS400のような「レガシー」と見なされがちな技術を学ぼうとする人は少ないのが現状です。

**IBMの対応策**

この状況を受けて、IBMは様々な対応策を講じています。

まず、開発環境のモダン化です。従来の5250端末ベースの開発環境に加えて、Visual Studio Code用の拡張機能「Code for IBM i」を提供し、現代的な開発環境でIBM iのプログラムを開発できるようにしています[8]。

また、教育プログラムの充実も図られています。IBM iの基礎から応用まで学べるオンライン学習コンテンツが提供されており、新しい技術者の育成を支援しています。

さらに、オープンソース技術との連携も強化されています。IBM i上でPython、Node.js、PHPなどの言語を実行できるPASE（Portable Application Solutions Environment）環境が提供されており、Web系エンジニアの知識を活用してIBM iシステムを拡張できるようになっています。

**将来性の展望**

2025年問題は確かに深刻ですが、IBM iの将来性が完全に失われたわけではありません。むしろ、この状況は新しい技術者にとってチャンスでもあります。

AS400/IBM i技術者の希少性により、この分野のスキルを持つ技術者の市場価値は高まっています。多くの企業がAS400システムの維持管理に苦労しており、経験豊富な技術者に対する需要は非常に高い状況です。

また、IBM iの技術的な進歩も続いています。最新のIBM i 7.6では、コンテナ技術への対応、AI/ML機能の統合、クラウドサービスとの連携強化などが図られており、現代的なIT要件に対応できるプラットフォームとして進化し続けています。

**モダナイゼーションの重要性**

AS400/IBM iシステムの将来性を確保するためには、モダナイゼーション（現代化）が重要です。これは、既存のAS400システムを完全に置き換えるのではなく、現代的な技術と連携させながら段階的に進化させるアプローチです。

具体的には、以下のような取り組みが行われています。

- Web APIの提供によるフロントエンドの刷新
- クラウドサービスとの連携
- データ分析基盤との接続
- モバイルアプリからのアクセス対応

このようなモダナイゼーションにより、AS400/IBM iシステムは現代的なITアーキテクチャの一部として機能し続けることができます。

**学習する価値**

Web系エンジニアの方がAS400/IBM iを学習することには、以下のような価値があります。

1. **希少性の高いスキル**: AS400技術者の不足により、このスキルを持つ技術者の市場価値は高い
2. **安定した需要**: 多くの企業がAS400システムを運用しており、長期的な需要が見込める
3. **システム設計の学習**: 統合システムの設計思想を学ぶことで、システムアーキテクチャの理解が深まる
4. **キャリアの多様化**: Web系技術とAS400技術の両方を理解することで、幅広いプロジェクトに対応できる

AS400/IBM iは確かに古い技術ですが、その設計思想や技術的な特徴には、現代のシステム開発においても学ぶべき点が多くあります。このチュートリアルを通じて、AS400/IBM iの世界を探求し、新しいスキルを身につけていただければと思います。



## 第2章：基本概念の理解

### 2.1 統合システムとしての特徴

IBM iを理解する上で最も重要な概念は、「統合システム」としての特徴です。Web系エンジニアの方には、この概念は最初は理解しにくいかもしれません。なぜなら、Web系システムでは各コンポーネントを独立して選択し、組み合わせることが一般的だからです。

**統合システムとは何か**

統合システムとは、ハードウェア、オペレーティングシステム、データベース、開発環境、実行環境が一体化されたシステムのことです。IBM iでは、これらの要素がすべてIBMによって設計・開発されており、相互に最適化されています。

Web系システムで例えるなら、フロントエンド、バックエンド、データベース、インフラがすべて同一ベンダーによって提供され、完全に統合されたソリューションとして動作するようなものです。しかし、実際のWeb系開発では、このような統合ソリューションは一般的ではありません。

**統合システムの利点**

統合システムの最大の利点は、システム全体の最適化が図られていることです。各コンポーネントが独立して開発されている場合、コンポーネント間の連携でボトルネックが発生することがあります。しかし、統合システムでは、このようなボトルネックを設計段階で排除できます。

具体的な利点を以下に示します。

**パフォーマンスの最適化**: データベースとアプリケーションが同一システム上で動作するため、ネットワーク通信のオーバーヘッドがありません。これにより、大量のデータを処理する際に優れたパフォーマンスを発揮します。

**運用管理の簡素化**: システム全体を単一の管理インターフェースで監視・制御できるため、運用管理が簡素化されます。Web系システムでは、フロントエンド、バックエンド、データベース、インフラをそれぞれ異なるツールで監視する必要がありますが、IBM iでは統合された管理ツールを使用できます。

**セキュリティの一貫性**: セキュリティポリシーがシステム全体で一貫して適用されます。Web系システムでは、各コンポーネントのセキュリティ設定を個別に管理する必要がありますが、IBM iでは統一されたセキュリティモデルが適用されます。

**互換性の保証**: すべてのコンポーネントが同一ベンダーによって開発されているため、バージョンアップ時の互換性問題が発生しにくくなります。

**統合システムの課題**

一方で、統合システムには以下のような課題もあります。

**ベンダーロックイン**: 特定のベンダー（この場合はIBM）に依存することになるため、他のソリューションへの移行が困難になります。

**技術選択の制約**: 新しい技術やツールを導入する際に、既存のシステムとの互換性を考慮する必要があります。

**初期コストの高さ**: 統合ソリューションは一般的に初期導入コストが高くなる傾向があります。

### 2.2 オブジェクト指向アーキテクチャ

IBM iのもう一つの重要な特徴は、「オブジェクト指向アーキテクチャ」です。ただし、ここで言うオブジェクト指向は、JavaやC#などのプログラミング言語で使われるオブジェクト指向プログラミングとは異なる概念です。

**IBM iにおけるオブジェクトとは**

IBM iでは、システム上のすべての要素が「オブジェクト」として管理されています。プログラム、データファイル、ユーザープロファイル、プリンター、ジョブキューなど、システム上に存在するあらゆるものがオブジェクトです。

各オブジェクトには以下の属性があります。

- **オブジェクト名**: オブジェクトを識別するための名前
- **オブジェクトタイプ**: オブジェクトの種類（*PGM、*FILE、*USRPRFなど）
- **ライブラリ**: オブジェクトが格納されている場所
- **所有者**: オブジェクトを所有するユーザー
- **権限**: オブジェクトに対するアクセス権限
- **作成日時**: オブジェクトが作成された日時
- **最終使用日時**: オブジェクトが最後に使用された日時

**オブジェクトの命名規則**

IBM iのオブジェクト名は、以下の規則に従います。

- 最大10文字
- 英数字とアンダースコア（_）、ドル記号（$）、アットマーク（@）、シャープ（#）が使用可能
- 最初の文字は英字、アンダースコア、ドル記号、アットマーク、シャープのいずれか
- 大文字と小文字は区別されない（内部的にはすべて大文字で管理）

Web系システムでファイル名やクラス名を付ける際の命名規則と比較すると、IBM iの命名規則はより制約が厳しいことがわかります。これは、IBM iが設計された1980年代の技術的制約を反映したものです。

**オブジェクトタイプ**

IBM iには数十種類のオブジェクトタイプが定義されています。主要なオブジェクトタイプを以下に示します。

| オブジェクトタイプ | 説明 | Web系での類似概念 |
|-------------------|------|------------------|
| *PGM | プログラム | 実行可能ファイル |
| *FILE | ファイル | データベーステーブル |
| *LIB | ライブラリ | ディレクトリ/スキーマ |
| *USRPRF | ユーザープロファイル | ユーザーアカウント |
| *JOBD | ジョブ記述 | プロセス設定 |
| *JOBQ | ジョブキュー | タスクキュー |
| *OUTQ | 出力キュー | 印刷キュー |
| *DTAARA | データ領域 | グローバル変数 |
| *MSGQ | メッセージキュー | ログファイル |

**オブジェクトの階層構造**

IBM iのオブジェクトは階層構造で管理されています。最上位にはシステム（QSYS）があり、その下にライブラリ、さらにその下に各種オブジェクトが配置されます。

```
QSYS (システム)
├── QSYS (システムライブラリ)
├── QGPL (汎用ライブラリ)
├── MYLIB (ユーザーライブラリ)
│   ├── MYPGM (*PGM)
│   ├── MYFILE (*FILE)
│   └── MYDTAARA (*DTAARA)
└── QTEMP (一時ライブラリ)
```

この階層構造は、Unixのディレクトリ構造に似ていますが、重要な違いがあります。Unixでは任意の深さの階層を作成できますが、IBM iでは基本的に2階層（ライブラリとオブジェクト）の構造になっています。

**オブジェクトの抽象化**

IBM iのオブジェクト指向アーキテクチャの最も重要な特徴は、ハードウェアやオペレーティングシステムの詳細からの抽象化です。プログラムやデータファイルは、物理的なストレージの詳細を意識することなく、オブジェクトとして操作できます。

この抽象化により、以下のような利点が得られます。

- **ハードウェア独立性**: プログラムはハードウェアの詳細を意識する必要がない
- **自動的な最適化**: システムがオブジェクトの配置や実行を最適化
- **透過的な移行**: ハードウェアやOSのアップグレード時にアプリケーションの修正が不要

### 2.3 ライブラリとオブジェクト

IBM iにおけるライブラリは、Web系システムにおけるディレクトリやデータベースのスキーマに相当する概念です。しかし、その機能と役割は、単純なディレクトリよりもはるかに高度です。

**ライブラリの概念**

ライブラリは、関連するオブジェクトをグループ化して管理するためのコンテナです。一つのライブラリには、プログラム、ファイル、データ領域など、様々な種類のオブジェクトを格納できます。

ライブラリの重要な特徴は以下の通りです。

**名前空間の提供**: 同じ名前のオブジェクトでも、異なるライブラリに格納されていれば区別されます。これにより、名前の衝突を避けることができます。

**アクセス制御**: ライブラリレベルでアクセス権限を設定できます。特定のライブラリに対する読み取り、書き込み、実行権限を個別に制御できます。

**バックアップ単位**: ライブラリ単位でバックアップや復元を行うことができます。

**配布単位**: アプリケーションをライブラリ単位で配布・インストールできます。

**システムライブラリ**

IBM iには、システムが使用する特別なライブラリがいくつか定義されています。

**QSYS**: システムの中核となるライブラリです。オペレーティングシステムのプログラムやシステム設定が格納されています。Web系システムで言えば、/usr/binや/etc に相当します。

**QGPL**: General Purpose Library（汎用ライブラリ）の略で、システム全体で共有されるオブジェクトが格納されます。ただし、本番環境では QGPL にユーザーオブジェクトを作成することは推奨されません。

**QTEMP**: 一時ライブラリで、ジョブ（プロセス）ごとに自動的に作成されます。ジョブが終了すると、QTEMP 内のオブジェクトは自動的に削除されます。Web系システムの /tmp ディレクトリに相当します。

**ライブラリリスト**

IBM iには「ライブラリリスト」という重要な概念があります。これは、オブジェクトを検索する際の優先順位を定義したリストです。

Web系開発で例えるなら、環境変数のPATHに似ています。シェルでコマンドを実行する際、システムはPATHに設定されたディレクトリを順番に検索してコマンドを見つけます。同様に、IBM iでオブジェクトを参照する際、システムはライブラリリストに設定されたライブラリを順番に検索します。

ライブラリリストは以下の部分で構成されます。

1. **システム部分**: システムライブラリ（QSYS、QHLPSYS、QSHELLなど）
2. **製品部分**: 製品固有のライブラリ
3. **現行ライブラリ**: デフォルトでオブジェクトが作成されるライブラリ
4. **ユーザー部分**: ユーザーが追加したライブラリ

**ライブラリの作成と管理**

ライブラリを作成するには、CRTLIB（Create Library）コマンドを使用します。

```
CRTLIB LIB(MYLIB) TEXT('My Application Library')
```

このコマンドは、'MYLIB' という名前のライブラリを作成します。TEXT パラメータは、ライブラリの説明文を指定します。

ライブラリを削除するには、DLTLIB（Delete Library）コマンドを使用します。

```
DLTLIB LIB(MYLIB)
```

ただし、ライブラリを削除する前に、ライブラリ内のすべてのオブジェクトを削除する必要があります。

**オブジェクトの参照方法**

IBM iでオブジェクトを参照する方法は、主に以下の3つです。

**1. 単純名による参照**
```
CALL MYPGM
```
この場合、システムはライブラリリストを順番に検索して、MYPGM という名前のプログラムを探します。

**2. 修飾名による参照**
```
CALL MYLIB/MYPGM
```
この場合、MYLIB ライブラリ内の MYPGM プログラムを直接指定します。

**3. 特殊値による参照**
```
CALL *LIBL/MYPGM
```
*LIBL は「ライブラリリスト」を意味する特殊値です。明示的にライブラリリスト検索を指定する場合に使用します。

### 2.4 ジョブとプロセス

IBM iにおける「ジョブ」は、Web系システムにおける「プロセス」に相当する概念です。しかし、IBM iのジョブは、単純なプロセスよりもはるかに高度な機能を持っています。

**ジョブとは何か**

ジョブは、IBM i上で実行される作業の単位です。ユーザーがシステムにログインすると、そのユーザーのためのジョブが作成されます。また、バッチ処理やシステム処理も、それぞれ独立したジョブとして実行されます。

ジョブには以下のような属性があります。

- **ジョブ名**: ジョブを識別するための名前
- **ユーザー名**: ジョブを実行するユーザー
- **ジョブ番号**: システムが自動的に割り当てる一意の番号
- **ジョブタイプ**: ジョブの種類（対話型、バッチ、システムなど）
- **優先度**: ジョブの実行優先度
- **CPU時間**: ジョブが使用したCPU時間
- **メモリ使用量**: ジョブが使用しているメモリ量

**ジョブの種類**

IBM iには、以下のような種類のジョブがあります。

**対話型ジョブ（Interactive Job）**: ユーザーがターミナルからシステムにログインして実行するジョブです。Web系システムで言えば、SSHセッションに相当します。

**バッチジョブ（Batch Job）**: バックグラウンドで実行される非対話型のジョブです。定期的なデータ処理や大量データの処理などに使用されます。Web系システムのcronジョブやバックグラウンドタスクに相当します。

**システムジョブ（System Job）**: システムが自動的に実行するジョブです。システムの監視、メンテナンス、通信処理などを行います。

**サーバージョブ（Server Job）**: 他のジョブからの要求を処理するジョブです。データベースサーバー、ファイルサーバー、通信サーバーなどがこれに該当します。

**ジョブの制御**

ジョブは、ジョブ記述（Job Description）というオブジェクトによって制御されます。ジョブ記述には、ジョブの実行環境に関する設定が定義されています。

ジョブ記述に含まれる主な設定項目は以下の通りです。

- **ジョブキュー**: ジョブが投入されるキュー
- **ライブラリリスト**: ジョブで使用するライブラリリスト
- **優先度**: ジョブの実行優先度
- **実行時間制限**: ジョブの最大実行時間
- **メモリ制限**: ジョブが使用できる最大メモリ量
- **出力キュー**: ジョブの出力先キュー

**ジョブキューとジョブスケジューラ**

バッチジョブは、ジョブキューというオブジェクトを通じて管理されます。ジョブキューは、実行待ちのジョブを格納するキューです。

IBM iのジョブスケジューラは、以下のような機能を提供します。

- **優先度制御**: ジョブの優先度に基づいて実行順序を制御
- **リソース管理**: CPU、メモリ、ディスクI/Oなどのリソース使用量を制御
- **依存関係管理**: ジョブ間の依存関係を定義して、順序立てて実行
- **スケジューリング**: 指定した日時にジョブを自動実行

**ジョブの監視と制御**

実行中のジョブは、WRKACTJOB（Work with Active Jobs）コマンドで監視できます。このコマンドを実行すると、現在実行中のすべてのジョブの一覧が表示されます。

```
WRKACTJOB
```

特定のジョブの詳細情報を確認するには、WRKJOB（Work with Job）コマンドを使用します。

```
WRKJOB JOB(123456/MYUSER/MYJOB)
```

ジョブを強制終了するには、ENDJOB（End Job）コマンドを使用します。

```
ENDJOB JOB(123456/MYUSER/MYJOB) OPTION(*IMMED)
```

### 2.5 セキュリティモデル

IBM iのセキュリティモデルは、オペレーティングシステムレベルで実装された包括的なセキュリティ機能です。Web系システムでは、アプリケーションレベルでセキュリティ対策を実装することが一般的ですが、IBM iでは多くのセキュリティ機能がシステムレベルで提供されています。

**多層防御アーキテクチャ**

IBM iのセキュリティは、多層防御（Defense in Depth）の考え方に基づいて設計されています。複数のセキュリティレイヤーが組み合わされることで、高いセキュリティレベルを実現しています。

1. **物理セキュリティ**: ハードウェアレベルでの保護
2. **システムセキュリティ**: オペレーティングシステムレベルでの保護
3. **ネットワークセキュリティ**: 通信レベルでの保護
4. **アプリケーションセキュリティ**: アプリケーションレベルでの保護
5. **データセキュリティ**: データレベルでの保護

**ユーザープロファイルとグループ**

IBM iでは、すべてのユーザーがユーザープロファイル（*USRPRF）オブジェクトとして管理されます。ユーザープロファイルには、以下のような情報が含まれています。

- **ユーザー名**: ユーザーを識別する名前
- **パスワード**: 認証用のパスワード
- **ユーザークラス**: ユーザーの権限レベル
- **グループプロファイル**: 所属するグループ
- **初期プログラム**: ログイン時に実行されるプログラム
- **初期メニュー**: ログイン時に表示されるメニュー
- **ライブラリリスト**: ユーザーのデフォルトライブラリリスト

**ユーザークラス**

IBM iでは、ユーザーを以下のクラスに分類して管理します。

| ユーザークラス | 説明 | 権限レベル |
|---------------|------|-----------|
| *SECOFR | セキュリティ責任者 | 最高権限 |
| *SECADM | セキュリティ管理者 | セキュリティ管理権限 |
| *PGMR | プログラマー | 開発権限 |
| *SYSOPR | システムオペレーター | 運用権限 |
| *USER | 一般ユーザー | 基本権限 |

**オブジェクトレベルセキュリティ**

IBM iでは、すべてのオブジェクトに対して詳細な権限制御が可能です。各オブジェクトには、以下のような権限を設定できます。

- ***ALL**: すべての権限
- ***CHANGE**: 変更権限
- ***USE**: 使用権限
- ***EXCLUDE**: アクセス拒否
- ***AUTL**: 認可リストによる制御

権限は、個別のユーザーまたはグループに対して設定できます。また、権限の継承も可能で、ライブラリの権限をその中のオブジェクトに継承させることができます。

**認証と認可**

IBM iの認証システムは、以下のような機能を提供します。

**パスワードポリシー**: パスワードの複雑さ、有効期限、履歴管理などを制御できます。

**多要素認証**: IBM i 7.6では、多要素認証（MFA）がサポートされており、より強固な認証が可能です[9]。

**シングルサインオン**: Kerberos認証やLDAP連携により、シングルサインオン環境を構築できます。

**監査機能**

IBM iには、包括的な監査機能が組み込まれています。以下のような活動を監査できます。

- **ログイン/ログアウト**: ユーザーのログイン履歴
- **オブジェクトアクセス**: オブジェクトへのアクセス履歴
- **権限変更**: セキュリティ設定の変更履歴
- **システム変更**: システム設定の変更履歴

監査ログは、改ざん防止機能により保護されており、セキュリティインシデントの調査に活用できます。

**暗号化機能**

IBM iは、データの暗号化機能も提供しています。

**フィールド暗号化**: データベースの特定のフィールドを暗号化できます。クレジットカード番号や個人情報などの機密データを保護するのに有効です。

**通信暗号化**: SSL/TLSによる通信の暗号化がサポートされています。

**ディスク暗号化**: ストレージレベルでのデータ暗号化も可能です。

**セキュリティレベル**

IBM iには、システム全体のセキュリティレベルを設定する機能があります。セキュリティレベルは10から50まで設定でき、レベルが高いほど厳格なセキュリティ制御が適用されます。

- **レベル10**: 最低限のセキュリティ（開発環境向け）
- **レベル20**: 基本的なセキュリティ
- **レベル30**: 標準的なセキュリティ（推奨）
- **レベル40**: 高度なセキュリティ
- **レベル50**: 最高レベルのセキュリティ

本番環境では、通常レベル30以上が推奨されます。

**Web系システムとの比較**

Web系システムのセキュリティと比較すると、IBM iのセキュリティには以下のような特徴があります。

**統合性**: セキュリティ機能がオペレーティングシステムレベルで統合されているため、一貫したセキュリティポリシーを適用できます。

**デフォルトセキュア**: システムのデフォルト設定が安全になっており、明示的に権限を付与しない限りアクセスできません。

**細粒度制御**: オブジェクトレベルでの詳細な権限制御が可能です。

**監査証跡**: 包括的な監査機能により、すべての活動が記録されます。

一方で、Web系システムの方が優れている点もあります。

**柔軟性**: 様々なセキュリティツールやフレームワークを組み合わせて使用できます。

**最新技術への対応**: OAuth、JWT、SAML などの最新の認証・認可技術を迅速に導入できます。

**コミュニティサポート**: オープンソースのセキュリティツールが豊富に利用できます。

IBM iのセキュリティモデルを理解することで、企業の基幹システムに求められる高いセキュリティレベルがどのように実現されているかを学ぶことができます。また、この知識は、Web系システムのセキュリティ設計にも活用できるでしょう。


## 第3章：Web系エンジニアが知っておくべき違い

### 3.1 ファイルシステムの違い

Web系エンジニアの方がIBM iを学習する際に最初に戸惑うのは、ファイルシステムの概念の違いです。Unix/LinuxやWindowsのファイルシステムに慣れ親しんだ方にとって、IBM iのファイルシステムは全く異なる世界に見えるかもしれません。

**階層ファイルシステム vs オブジェクトベースシステム**

Unix/Linuxでは、すべてのファイルが階層的なディレクトリ構造で管理されています。ルートディレクトリ（/）から始まり、任意の深さまでディレクトリを作成できます。

```
/
├── home
│   └── user
│       ├── documents
│       │   └── project
│       │       └── file.txt
│       └── downloads
├── var
│   └── log
└── etc
```

一方、IBM iでは、ファイルは「オブジェクト」として管理され、基本的に2階層の構造（ライブラリ/オブジェクト）になっています。

```
QSYS
├── MYLIB
│   ├── MYFILE (*FILE)
│   ├── MYPGM (*PGM)
│   └── MYDTAARA (*DTAARA)
├── TESTLIB
│   ├── TESTFILE (*FILE)
│   └── TESTPGM (*PGM)
└── QGPL
    └── TEMPFILE (*FILE)
```

**ファイルの概念の違い**

Unix/Linuxでは、「ファイル」は単純にデータの集合体です。テキストファイル、バイナリファイル、実行ファイルなど、様々な種類のファイルがありますが、基本的にはバイト列として扱われます。

IBM iでは、「ファイル」はより構造化されたデータの集合体です。IBM iのファイルには、以下のような種類があります。

**物理ファイル（Physical File）**: 実際のデータが格納されるファイルです。Web系システムのデータベーステーブルに相当します。

**論理ファイル（Logical File）**: 物理ファイルのデータに対するビュー（視点）を定義するファイルです。SQLのビューに相当します。

**表示ファイル（Display File）**: 画面の表示形式を定義するファイルです。Web系システムのHTMLテンプレートに相当します。

**印刷ファイル（Printer File）**: 印刷出力の形式を定義するファイルです。

**ソースファイル（Source File）**: プログラムのソースコードを格納するファイルです。

**レコード指向 vs ストリーム指向**

Unix/Linuxのファイルは「ストリーム指向」です。ファイルは連続したバイト列として扱われ、アプリケーションが任意の位置からデータを読み書きできます。

```python
# Pythonでのファイル読み込み例
with open('data.txt', 'r') as f:
    content = f.read()  # ファイル全体を読み込み
    f.seek(100)         # 100バイト目に移動
    chunk = f.read(50)  # 50バイト読み込み
```

IBM iのファイルは「レコード指向」です。ファイルは固定長または可変長のレコードの集合として扱われ、レコード単位でデータを読み書きします。

```rpg
// RPGでのファイル読み込み例
Read MYFILE;                    // 1レコード読み込み
If %EOF(MYFILE);               // ファイル終端チェック
  // 処理終了
Else;
  // レコード処理
EndIf;
```

**メタデータの管理**

Unix/Linuxでは、ファイルのメタデータ（作成日時、権限、所有者など）は、ファイルシステムによって管理されます。

IBM iでは、オブジェクトのメタデータはより豊富で、システムが自動的に管理します。各オブジェクトには以下のような情報が含まれています。

- オブジェクト名、タイプ、ライブラリ
- 作成日時、最終変更日時、最終使用日時
- 所有者、権限設定
- サイズ、レコード数（ファイルの場合）
- 依存関係情報
- 説明文

**ファイルアクセスの方法**

Unix/Linuxでは、ファイルパスを指定してファイルにアクセスします。

```bash
cat /home/user/documents/data.txt
```

IBM iでは、ライブラリ名とオブジェクト名を指定してアクセスします。

```
DSPPFM FILE(MYLIB/MYFILE)
```

また、ライブラリリストに登録されているライブラリのオブジェクトは、ライブラリ名を省略してアクセスできます。

```
DSPPFM FILE(MYFILE)
```

**統合ファイルシステム（IFS）**

IBM iには、従来のライブラリ/オブジェクト構造に加えて、「統合ファイルシステム（Integrated File System: IFS）」も提供されています。IFSは、Unix/Linuxのような階層ファイルシステムで、以下のような特徴があります。

- 任意の深さのディレクトリ構造
- ストリーム指向のファイル
- Unix/Linux互換のAPIサポート
- 長いファイル名（255文字まで）
- 大文字小文字の区別

IFSは、主に以下のような用途で使用されます。

- Webアプリケーションのファイル
- XMLやJSONなどの構造化データ
- ログファイル
- 一時ファイル
- オープンソースアプリケーションのファイル

**ファイルシステムの使い分け**

IBM iでは、用途に応じてファイルシステムを使い分けます。

| 用途 | ファイルシステム | 理由 |
|------|-----------------|------|
| 業務データ | ライブラリ/オブジェクト | 構造化データ、高性能、統合管理 |
| プログラム | ライブラリ/オブジェクト | オブジェクト管理、依存関係追跡 |
| Webファイル | IFS | 階層構造、長いファイル名 |
| ログファイル | IFS | ストリーム指向、Unix互換 |
| 一時ファイル | IFS | 柔軟なアクセス |

### 3.2 データベースの統合

IBM iの最も特徴的な機能の一つは、データベース（DB2 for i）がオペレーティングシステムに完全に統合されていることです。Web系システムでは、アプリケーションサーバーとデータベースサーバーが分離されているのが一般的ですが、IBM iでは両者が一体化されています。

**統合データベースの概念**

Web系システムでは、通常以下のような構成になります。

```
Webサーバー (Apache/Nginx)
    ↓ HTTP
アプリケーションサーバー (Node.js/Python/Java)
    ↓ TCP/IP (SQL)
データベースサーバー (MySQL/PostgreSQL)
```

この構成では、アプリケーションとデータベース間の通信にネットワークオーバーヘッドが発生します。また、それぞれのコンポーネントを個別に管理する必要があります。

IBM iでは、以下のような統合構成になります。

```
IBM i システム
├── アプリケーション (RPG/COBOL/Java)
└── データベース (DB2 for i)
    ↑ 直接メモリアクセス
```

この統合により、以下のような利点が得られます。

**高速なデータアクセス**: ネットワーク通信が不要なため、データアクセスが高速です。

**トランザクションの一貫性**: アプリケーションとデータベースが同一システム上で動作するため、トランザクションの一貫性を保ちやすくなります。

**運用管理の簡素化**: 単一システムとして管理できるため、運用が簡素化されます。

**自動最適化**: システムがアプリケーションとデータベースの両方を把握しているため、自動的な最適化が可能です。

**DB2 for iの特徴**

DB2 for iは、IBM iに統合されたリレーショナルデータベース管理システムです。以下のような特徴があります。

**自動管理機能**: インデックスの自動作成、統計情報の自動更新、クエリ最適化の自動実行など、多くの管理作業が自動化されています。

**高い可用性**: システムレベルでの冗長化により、高い可用性を実現しています。

**スケーラビリティ**: 大量のデータと高い同時実行性をサポートしています。

**SQL標準準拠**: ANSI SQL標準に準拠しており、標準的なSQLを使用できます。

**ファイルとテーブルの関係**

IBM iでは、「ファイル」と「テーブル」は同じものを指します。物理ファイルがデータベーステーブルに相当し、論理ファイルがビューに相当します。

```sql
-- SQLでテーブル作成
CREATE TABLE MYLIB.CUSTOMER (
    CUSTNO INT NOT NULL PRIMARY KEY,
    NAME VARCHAR(50),
    ADDRESS VARCHAR(100)
);
```

このSQLで作成されたテーブルは、IBM iでは物理ファイル MYLIB/CUSTOMER として管理されます。

**DDS vs SQL**

IBM iでは、ファイル（テーブル）を定義する方法が2つあります。

**DDS（Data Description Specifications）**: IBM i独自のファイル定義言語です。

```
     A          R CUSTREC
     A            CUSTNO         5P 0
     A            NAME          50A
     A            ADDRESS      100A
     A          K CUSTNO
```

**SQL**: 標準的なSQL DDL（Data Definition Language）です。

```sql
CREATE TABLE CUSTOMER (
    CUSTNO DECIMAL(5,0) NOT NULL PRIMARY KEY,
    NAME CHAR(50),
    ADDRESS CHAR(100)
);
```

現在では、SQLを使用することが推奨されていますが、既存のシステムではDDSで定義されたファイルも多く存在します。

**埋め込みSQL**

IBM iでは、RPGやCOBOLなどの言語にSQLを埋め込むことができます。これにより、高性能なデータアクセスが可能になります。

```rpg
// RPGでの埋め込みSQL例
Exec SQL
  SELECT NAME, ADDRESS
  INTO :customerName, :customerAddress
  FROM CUSTOMER
  WHERE CUSTNO = :customerNumber;

If SQLCODE = 0;
  // データが見つかった場合の処理
Else;
  // データが見つからなかった場合の処理
EndIf;
```

**ストアドプロシージャとユーザー定義関数**

DB2 for iは、ストアドプロシージャとユーザー定義関数をサポートしています。これらは、SQLまたはRPG、COBOLなどの言語で作成できます。

```sql
-- SQLストアドプロシージャの例
CREATE PROCEDURE GET_CUSTOMER_INFO(
    IN CUST_NO INT,
    OUT CUST_NAME VARCHAR(50),
    OUT CUST_ADDR VARCHAR(100)
)
LANGUAGE SQL
BEGIN
    SELECT NAME, ADDRESS
    INTO CUST_NAME, CUST_ADDR
    FROM CUSTOMER
    WHERE CUSTNO = CUST_NO;
END;
```

**JSON サポート**

最新のDB2 for iでは、JSONデータの格納と操作もサポートされています。これにより、NoSQLライクなデータ操作も可能です。

```sql
-- JSONデータの操作例
CREATE TABLE ORDERS (
    ORDER_ID INT,
    ORDER_DATA JSON
);

INSERT INTO ORDERS VALUES (
    1,
    '{"customer": "John Doe", "items": [{"product": "Laptop", "price": 1000}]}'
);

SELECT JSON_VALUE(ORDER_DATA, '$.customer')
FROM ORDERS
WHERE ORDER_ID = 1;
```

### 3.3 文字コードとEBCDIC

Web系エンジニアの方がIBM iで最初に困惑するのは、文字コードの違いです。Web系システムでは一般的にUTF-8やASCIIが使用されますが、IBM iでは伝統的にEBCDIC（Extended Binary Coded Decimal Interchange Code）が使用されています。

**EBCDIC vs ASCII/UTF-8**

ASCIIとEBCDICは、どちらも文字をバイナリコードで表現する方式ですが、文字とコードの対応が異なります。

例えば、文字 'A' の場合：
- ASCII: 0x41 (65)
- EBCDIC: 0xC1 (193)

この違いにより、ASCIIベースのシステムとEBCDICベースのシステム間でデータを交換する際には、文字コード変換が必要になります。

**なぜEBCDICなのか**

EBCDICは、IBMが1960年代に開発した文字コード体系です。メインフレームの時代から使用されており、IBM iもその伝統を受け継いでいます。

EBCDICの特徴：
- 8ビット文字コード（256文字まで表現可能）
- ソート順序が文字の自然な順序と一致
- 数値データの処理に最適化
- パック10進数との親和性が高い

**現在のIBM iでの文字コード処理**

現在のIBM iでは、EBCDICだけでなく、ASCIIやUTF-8もサポートされています。特に、以下のような場面では適切な文字コードが自動的に選択されます。

**IFS（統合ファイルシステム）**: UTF-8やASCIIを使用
**Webサービス**: UTF-8を使用
**データベース**: EBCDICまたはUTF-8を選択可能
**5250端末**: EBCDICを使用

**文字コード変換**

IBM iには、文字コード間の変換機能が組み込まれています。

```sql
-- SQLでの文字コード変換例
SELECT CONVERT('Hello World', 37, 1208) FROM SYSIBM.SYSDUMMY1;
-- 37: EBCDIC, 1208: UTF-8
```

**国際化対応**

IBM iは、多言語環境をサポートしています。日本語環境では、以下のような文字コードが使用されます。

- **EBCDIC**: 日本語EBCDIC（CCSID 5026、5035など）
- **ASCII**: Shift_JIS（CCSID 943）
- **Unicode**: UTF-8（CCSID 1208）、UTF-16（CCSID 1200）

**実際の開発での注意点**

Web系エンジニアがIBM iで開発する際の文字コード関連の注意点：

1. **データ交換**: 外部システムとのデータ交換時には文字コード変換を考慮
2. **ファイル処理**: IFSとライブラリ/オブジェクトで文字コードが異なる可能性
3. **Webアプリケーション**: Web画面とバックエンド処理で文字コードを統一
4. **ログ出力**: ログファイルの文字コードを明確に指定

### 3.4 ネットワークとプロトコル

IBM iのネットワーク機能は、Web系システムとは異なる特徴を持っています。IBM i独自のプロトコルと標準的なTCP/IPプロトコルの両方をサポートしており、用途に応じて使い分けられています。

**SNA vs TCP/IP**

IBM iは、伝統的にSNA（Systems Network Architecture）というIBM独自のネットワークアーキテクチャを使用してきました。SNAは、メインフレーム時代から使用されている信頼性の高いプロトコルです。

**SNA の特徴**：
- 高い信頼性とエラー回復機能
- セッション管理の自動化
- 優先度制御
- セキュリティ機能の統合

**TCP/IP の特徴**：
- インターネット標準プロトコル
- オープンな仕様
- 豊富なアプリケーションサポート
- クラウドサービスとの親和性

現在のIBM iでは、両方のプロトコルをサポートしており、用途に応じて選択できます。

**5250プロトコル**

IBM iの特徴的なプロトコルの一つが5250です。これは、端末とサーバー間の通信に使用されるプロトコルで、以下のような特徴があります。

- **ブロックモード通信**: 画面全体を一度に送受信
- **フィールド単位制御**: 画面上の各フィールドを個別に制御
- **カーソル制御**: カーソル位置の精密な制御
- **色彩・属性制御**: 文字の色や属性（点滅、反転など）の制御

Web系システムのHTTPプロトコルと比較すると、5250は以下のような違いがあります。

| 項目 | HTTP | 5250 |
|------|------|------|
| 通信方式 | リクエスト/レスポンス | セッション指向 |
| データ形式 | テキスト（HTML/JSON） | バイナリ |
| 状態管理 | ステートレス | ステートフル |
| 画面制御 | クライアント側（JavaScript） | サーバー側 |

**Webサービスとの統合**

現在のIBM iでは、Webサービスとの統合も強化されています。

**RESTful Webサービス**: IBM iのプログラムをRESTful APIとして公開できます。

```rpg
// RPGプログラムをWebサービスとして公開
Dcl-Proc getCustomerInfo Export;
  Dcl-Pi *N;
    customerNo Int(10) Const;
    customerData Varchar(1000);
  End-Pi;
  
  // 顧客情報取得処理
  Exec SQL
    SELECT JSON_OBJECT(
      'name': NAME,
      'address': ADDRESS
    )
    INTO :customerData
    FROM CUSTOMER
    WHERE CUSTNO = :customerNo;
End-Proc;
```

**SOAP Webサービス**: 従来のSOAPベースのWebサービスもサポートされています。

**JSON/XML処理**: 最新のIBM iでは、JSONやXMLの処理機能が大幅に強化されています。

### 3.5 開発手法の違い

Web系システムとIBM iでは、開発手法にも大きな違いがあります。これらの違いを理解することで、IBM iでの効率的な開発が可能になります。

**ウォーターフォール vs アジャイル**

IBM iの開発では、伝統的にウォーターフォール型の開発手法が採用されてきました。これは、以下のような理由によるものです。

- **安定性重視**: 基幹システムでは安定性が最優先
- **長期運用**: 一度構築したシステムを長期間使用
- **変更コスト**: システム変更のコストとリスクが高い
- **規制要件**: 金融や製造業では厳格な開発プロセスが要求される

一方、Web系システムでは、アジャイル開発が主流になっています。

- **迅速な市場投入**: 短期間でのリリースが重要
- **継続的改善**: 小さな改善を継続的に実施
- **ユーザーフィードバック**: ユーザーの反応を素早く取り入れ
- **技術革新**: 新しい技術を積極的に採用

**開発環境の違い**

Web系開発では、以下のような環境が一般的です。

```
開発者PC (Windows/Mac/Linux)
├── エディタ (VS Code/IntelliJ/Vim)
├── バージョン管理 (Git)
├── パッケージ管理 (npm/pip/Maven)
├── ビルドツール (Webpack/Gradle/Make)
└── デプロイツール (Docker/Kubernetes)
```

IBM i開発では、以下のような環境が使用されます。

```
IBM i システム
├── 5250端末エミュレータ
├── PDM (Program Development Manager)
├── SEU (Source Entry Utility)
├── コンパイラ (RPG/COBOL/CL)
└── ライブラリ管理
```

ただし、最近では以下のような現代的な開発環境も利用できるようになっています。

```
開発者PC
├── VS Code + Code for IBM i
├── Git連携
├── RDi (Rational Developer for i)
└── IBM i Access Client Solutions
```

**バージョン管理**

Web系開発では、Gitが標準的なバージョン管理システムとして使用されています。

IBM iでは、伝統的に以下のような方法でバージョン管理が行われてきました。

- **ライブラリ分離**: 開発、テスト、本番でライブラリを分離
- **ソースメンバー管理**: ソースファイル内でメンバー単位で管理
- **変更管理**: 変更管理システムによる手動管理

最近では、IBM i でもGitを使用したバージョン管理が可能になっています。

**テスト手法**

Web系開発では、以下のようなテスト手法が一般的です。

- **単体テスト**: Jest、JUnit、PyTestなど
- **統合テスト**: API テスト、E2Eテスト
- **自動化**: CI/CDパイプラインでの自動テスト
- **TDD/BDD**: テスト駆動開発、振る舞い駆動開発

IBM i開発では、以下のようなテスト手法が使用されます。

- **手動テスト**: 5250画面での手動操作テスト
- **バッチテスト**: バッチジョブでのデータ処理テスト
- **統合テスト**: システム全体での統合テスト
- **回帰テスト**: 既存機能への影響確認

**デプロイメント**

Web系システムでは、以下のようなデプロイメント手法が使用されます。

```bash
# 例：Node.jsアプリケーションのデプロイ
git pull origin main
npm install
npm run build
pm2 restart app
```

IBM iでは、以下のような手順でデプロイメントが行われます。

```
1. ソースコンパイル
   CRTPGM PGM(PRODLIB/MYPGM) SRCFILE(DEVLIB/QRPGSRC)

2. オブジェクト移動
   CPYOBJ OBJ(MYPGM) FROMLIB(TESTLIB) TOLIB(PRODLIB)

3. 権限設定
   GRTOBJAUT OBJ(PRODLIB/MYPGM) OBJTYPE(*PGM) USER(*PUBLIC) AUT(*USE)
```

**現代的な開発手法の導入**

最近のIBM i開発では、Web系の開発手法を取り入れる動きが見られます。

**DevOps**: 開発と運用の連携強化
**CI/CD**: 継続的インテグレーション・デプロイメント
**Infrastructure as Code**: インフラの自動化
**監視・ログ**: アプリケーション監視の強化

これらの手法により、IBM i開発の効率性と品質が向上しています。

**学習のポイント**

Web系エンジニアがIBM i開発を学習する際のポイント：

1. **既存知識の活用**: SQLやプログラミングの基本概念は共通
2. **違いの理解**: ファイルシステムや開発手法の違いを理解
3. **段階的学習**: 基本概念から実践的なスキルへ段階的に学習
4. **実践重視**: PUB400.comなどを活用した実践的な学習
5. **コミュニティ活用**: IBM iコミュニティとの交流

これらの違いを理解することで、Web系エンジニアの方もIBM iの世界を効率的に学習できるでしょう。次の章では、実際に手を動かしながらIBM iの環境構築と基本操作を学んでいきます。


---

# 第2部：環境構築と基本操作編

## 第4章：学習環境の構築

### 4.1 PUB400.comの利用方法

IBM iを学習する上で最も大きな障壁の一つは、学習環境の確保です。IBM iシステムは高価であり、個人で購入することは現実的ではありません。しかし、幸いなことに、PUB400.comという無料のIBM i学習環境が提供されています[10]。

**PUB400.comとは**

PUB400.comは、ドイツのRZKH GmbHが運営する無料のIBM i学習環境です。世界中の開発者やIBM i学習者が利用しており、実際のIBM iシステムと同等の機能を提供しています。このサービスは、IBM iコミュニティの発展と新しい技術者の育成を目的として運営されています。

PUB400.comの特徴は以下の通りです。

**完全無料**: 登録から利用まで、すべて無料で提供されています。商用利用は禁止されていますが、学習目的であれば制限なく利用できます。

**最新バージョン**: IBM i 7.4が稼働しており、最新の機能を学習できます。定期的にシステムがアップデートされ、新しい機能も追加されています。

**フルアクセス**: 5250端末エミュレータ、SSH、FTPなど、様々な方法でシステムにアクセスできます。また、プログラム開発、ファイル操作、システム管理など、実際の業務で必要な機能をすべて利用できます。

**コミュニティサポート**: PUB400.comには専用のフォーラムがあり、他の学習者や経験豊富な開発者と情報交換ができます。

**アカウント登録手順**

PUB400.comのアカウント登録は、以下の手順で行います。

**ステップ1: 登録ページへのアクセス**

Webブラウザで http://www.pub400.com にアクセスします。トップページに「Request New Profile」というリンクがあるので、これをクリックします。

**ステップ2: 登録情報の入力**

登録フォームでは、以下の情報を入力します。

- **User ID**: 希望するユーザーID（8文字以内、英数字のみ）
- **First Name**: 名前
- **Last Name**: 姓
- **Email Address**: メールアドレス
- **Country**: 国名
- **Company/Organization**: 会社名または所属組織（個人の場合は「Individual」など）
- **Intended Use**: 利用目的（「Learning IBM i」など）

すべての項目を入力したら、「Submit」ボタンをクリックします。

**ステップ3: メール確認**

登録後、数分以内に確認メールが送信されます。メールが迷惑メールフォルダに入ることがあるので、受信トレイに見当たらない場合は迷惑メールフォルダも確認してください。

確認メールには、メールアドレスの検証用リンクが含まれています。このリンクをクリックして、メールアドレスの確認を完了します。

**ステップ4: アカウント情報の受信**

メールアドレスの確認が完了すると、さらに数分後に2通目のメールが送信されます。このメールには、以下の情報が含まれています。

- **ユーザーID**: 登録したユーザーID
- **初期パスワード**: システムが自動生成したパスワード
- **接続方法**: システムへの接続手順
- **利用規約**: システム利用時の注意事項

**利用規約と注意事項**

PUB400.comを利用する際は、以下の利用規約を遵守する必要があります。

**商用利用の禁止**: システムは学習目的でのみ利用可能で、商用利用は禁止されています。

**他ユーザーへの配慮**: 他のユーザーの作業を妨害してはいけません。システムリソースを独占するような処理は避けてください。

**データの機密性**: 他のユーザーのデータを覗き見したり、アクセスしたりしてはいけません。

**バックアップなし**: システムのデータはバックアップされていません。重要なデータは定期的に自分でバックアップを取ってください。

**QGPL使用禁止**: QGPL ライブラリにオブジェクトを作成してはいけません。作成されたオブジェクトは自動的に削除されます。

**システムメンテナンス**: システムは定期的にメンテナンスのため停止することがあります。事前通知なしに停止する場合もあります。

### 4.2 5250エミュレータのセットアップ

IBM iシステムにアクセスするためには、5250端末エミュレータが必要です。5250は、IBM iの標準的な端末プロトコルで、文字ベースのインターフェースを提供します。Web系エンジニアの方には馴染みがないかもしれませんが、SSH端末に似た概念と考えてください。

**5250エミュレータの選択**

5250エミュレータには、無料のものから商用のものまで様々な選択肢があります。学習目的であれば、以下の無料エミュレータがおすすめです。

**Windows環境**

**TN5250J**: Javaベースのクロスプラットフォーム対応エミュレータです。機能が豊富で、カスタマイズ性に優れています。

**Mocha TN5250**: シンプルで使いやすいエミュレータです。基本的な機能に特化しており、初心者にも扱いやすいです。

**macOS環境**

**Mocha TN5250 Lite**: Mac App Storeから無料でダウンロードできます。基本的な5250機能を提供しており、学習には十分です。

**TN5250J**: Windows版と同じく、macOSでも利用できます。

**Linux環境**

**tn5250**: コマンドラインベースのエミュレータです。軽量で高速ですが、GUIはありません。

**TN5250J**: Linux環境でも利用できます。

**TN5250Jのセットアップ（推奨）**

ここでは、最も機能が豊富で安定しているTN5250Jのセットアップ方法を説明します。

**ステップ1: Javaのインストール**

TN5250JはJavaアプリケーションなので、事前にJavaランタイム（JRE）をインストールする必要があります。

Windows/macOS: Oracle JDKまたはOpenJDKをダウンロードしてインストールします。

Linux: パッケージマネージャーを使用してインストールします。
```bash
# Ubuntu/Debian
sudo apt-get install openjdk-11-jre

# CentOS/RHEL
sudo yum install java-11-openjdk
```

**ステップ2: TN5250Jのダウンロード**

TN5250Jの公式サイト（http://tn5250j.org）から最新版をダウンロードします。ZIPファイルをダウンロードして、適当なディレクトリに展開します。

**ステップ3: 接続設定の作成**

TN5250Jを起動すると、セッション管理画面が表示されます。新しい接続を作成するために、以下の手順を実行します。

1. 「Configure」メニューから「Sessions」を選択
2. 「Add」ボタンをクリックして新しいセッションを作成
3. セッション設定で以下の項目を入力：
   - **Session Name**: PUB400（任意の名前）
   - **Host Name/IP**: PUB400.COM
   - **Port**: 23（デフォルト）
   - **Device Name**: 空白のまま
   - **Code Page**: 1399（日本語環境の場合）

**ステップ4: 接続テスト**

設定が完了したら、「Connect」ボタンをクリックして接続をテストします。正常に接続されると、IBM iのサインオン画面が表示されます。

**5250画面の基本構成**

5250端末画面は、24行×80列の文字ベースの画面です。Web系システムのGUIとは大きく異なりますが、効率的な操作が可能です。

画面の基本構成は以下の通りです。

**ヘッダー行（1行目）**: システム名、日付、時刻などが表示されます。

**メッセージ行（24行目）**: システムからのメッセージやエラー情報が表示されます。

**入力フィールド**: 下線で表示される領域で、データを入力できます。

**保護フィールド**: 通常の文字で表示される領域で、入力はできません。

**ファンクションキー行**: 画面下部に利用可能なファンクションキーが表示されます。

**文字属性**

5250画面では、文字の属性（色、強調表示など）を使って情報を区別します。

- **緑色**: 通常のテキスト
- **白色**: 入力フィールド
- **赤色**: エラーメッセージ
- **黄色**: 警告メッセージ
- **青色**: ヘッダー情報
- **点滅**: 注意が必要な項目
- **反転**: 選択された項目

**キーボード操作**

5250端末では、特殊なキー操作が必要です。Web系システムのキーボード操作とは異なる点があります。

**Enter キー**: 画面の内容をサーバーに送信します。Webフォームの送信ボタンに相当します。

**Tab キー**: 次の入力フィールドに移動します。

**Shift + Tab**: 前の入力フィールドに移動します。

**ファンクションキー（F1-F24）**: 様々な機能を実行します。画面下部に利用可能なキーが表示されます。

**フィールドエクジット**: 入力フィールドから抜ける際に使用します。通常はTabキーまたは特定のキーを使用します。

### 4.3 初回ログインと基本設定

PUB400.comへの初回ログインでは、いくつかの初期設定を行う必要があります。これらの設定により、より快適にシステムを利用できるようになります。

**初回ログイン手順**

**ステップ1: サインオン画面**

5250エミュレータでPUB400.comに接続すると、以下のようなサインオン画面が表示されます。

```
                        Sign On
                                                System:   PUB400
                                                Subsystem:  QINTER
                                                Display:  . . . . . . . . . . . .

User  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
```

## 第5章：基本コマンドの習得

### 5.1 コマンドラインの基本概念

IBM iのコマンドラインは、Web系システムのシェル（bash、zsh等）とは大きく異なる特徴を持っています。IBM iでは、コマンドは「CL（Control Language）」と呼ばれる専用の言語で記述されており、システムの操作や管理を行うための強力なツールです。

**CLコマンドの特徴**

IBM iのCLコマンドは、以下のような特徴があります。

**動詞-名詞構造**: CLコマンドは、動詞（動作）と名詞（対象）の組み合わせで構成されています。例えば、「CRTLIB」は「CREATE LIBRARY」の略で、ライブラリを作成するコマンドです。

**パラメータ指定**: コマンドには多数のパラメータがあり、キーワード形式で指定します。Unix/Linuxのオプション（-オプション）とは異なり、より明示的で読みやすい形式になっています。

**ヘルプ機能**: すべてのコマンドに詳細なヘルプが用意されており、F1キーでアクセスできます。

**プロンプト機能**: コマンドを入力する際に、F4キーでプロンプト画面を表示し、パラメータを対話的に入力できます。

**コマンドの基本構文**

CLコマンドの基本構文は以下の通りです。

```
COMMAND PARAMETER1(value1) PARAMETER2(value2) ...
```

例：
```
CRTLIB LIB(MYLIB) TEXT('My Library')
```

この例では、「CRTLIB」がコマンド、「LIB(MYLIB)」と「TEXT('My Library')」がパラメータです。

**Web系システムとの比較**

Web系システムでよく使用されるコマンドとIBM iのコマンドを比較してみましょう。

| 操作 | Unix/Linux | IBM i |
|------|------------|-------|
| ディレクトリ作成 | `mkdir mydir` | `CRTLIB LIB(MYLIB)` |
| ファイル一覧 | `ls -l` | `WRKOBJ OBJ(MYLIB/*) OBJTYPE(*ALL)` |
| ファイル削除 | `rm filename` | `DLTOBJ OBJ(MYLIB/MYFILE) OBJTYPE(*FILE)` |
| プロセス確認 | `ps aux` | `WRKACTJOB` |
| ディスク使用量 | `df -h` | `WRKSYSSTS` |

### 5.2 ライブラリとオブジェクトの管理

IBM iでは、すべてのデータとプログラムが「オブジェクト」として管理され、これらのオブジェクトは「ライブラリ」に格納されます。これは、Web系システムのファイルシステムとは根本的に異なる概念です。

**ライブラリの作成と管理**

ライブラリは、IBM iにおけるオブジェクトの入れ物です。Web系システムのディレクトリに相当しますが、より構造化された管理が行われます。

**ライブラリの作成**

```
CRTLIB LIB(TESTLIB) TEXT('Test Library for Learning')
```

このコマンドで、「TESTLIB」という名前のライブラリを作成します。TEXTパラメータは、ライブラリの説明文を指定します。

**ライブラリの一覧表示**

```
WRKLIB LIB(TEST*)
```

このコマンドで、「TEST」で始まるライブラリの一覧を表示します。ワイルドカード（*）を使用して、複数のライブラリを指定できます。

**ライブラリの削除**

```
DLTLIB LIB(TESTLIB)
```

ライブラリを削除する際は、ライブラリ内にオブジェクトが存在しないことを確認してください。オブジェクトが存在する場合は、先にオブジェクトを削除する必要があります。

**オブジェクトの管理**

IBM iでは、ファイル、プログラム、データエリアなど、すべてが「オブジェクト」として扱われます。各オブジェクトには「オブジェクトタイプ」が設定されており、用途に応じて分類されています。

**主要なオブジェクトタイプ**

| オブジェクトタイプ | 説明 | 例 |
|-------------------|------|-----|
| *FILE | データファイル | 顧客マスタ、売上データ |
| *PGM | プログラム | RPG、COBOLプログラム |
| *DTAARA | データエリア | 共有変数、設定値 |
| *USRSPC | ユーザースペース | 一時的なデータ格納 |
| *SRCPF | ソースファイル | プログラムソースコード |

**オブジェクトの一覧表示**

```
WRKOBJ OBJ(TESTLIB/*) OBJTYPE(*ALL)
```

このコマンドで、TESTLIB内のすべてのオブジェクトを表示します。OBJTYPEパラメータで特定のタイプのオブジェクトのみを表示することも可能です。

```
WRKOBJ OBJ(TESTLIB/*) OBJTYPE(*FILE)
```

**オブジェクトの詳細情報表示**

```
DSPOBJD OBJ(TESTLIB/MYFILE) OBJTYPE(*FILE)
```

このコマンドで、オブジェクトの詳細情報（作成日時、サイズ、権限など）を表示します。

**オブジェクトのコピー**

```
CPYOBJ FROMOBJ(SOURCELIB/MYFILE) OBJTYPE(*FILE) TOLIB(TESTLIB)
```

オブジェクトを別のライブラリにコピーします。Web系システムの`cp`コマンドに相当します。

**オブジェクトの削除**

```
DLTOBJ OBJ(TESTLIB/MYFILE) OBJTYPE(*FILE)
```

指定したオブジェクトを削除します。削除前に、他のオブジェクトから参照されていないことを確認してください。

**ライブラリリストの管理**

IBM iでは、「ライブラリリスト」という概念があります。これは、オブジェクトを検索する際の優先順位を定義するリストです。Web系システムの環境変数PATHに似た概念です。

**現在のライブラリリストの表示**

```
DSPLIBL
```

このコマンドで、現在のライブラリリストを表示します。リストには、システムライブラリ、製品ライブラリ、ユーザーライブラリが含まれます。

**ライブラリリストへの追加**

```
ADDLIBLE LIB(TESTLIB)
```

指定したライブラリをライブラリリストに追加します。これにより、オブジェクト名のみでアクセスできるようになります。

**ライブラリリストからの削除**

```
RMVLIBLE LIB(TESTLIB)
```

指定したライブラリをライブラリリストから削除します。

**現在ライブラリの設定**

```
CHGCURLIB CURLIB(TESTLIB)
```

現在ライブラリを設定します。現在ライブラリに設定されたライブラリは、新しく作成されるオブジェクトのデフォルトの格納先になります。

### 5.3 ファイル操作の基本

IBM iでのファイル操作は、Web系システムとは大きく異なります。IBM iでは、「ファイル」はデータベーステーブルとして扱われ、レコード指向の操作が基本となります。

**ファイルの種類**

IBM iには、以下のような種類のファイルがあります。

**物理ファイル（Physical File）**: 実際のデータが格納されるファイルです。Web系システムのデータベーステーブルに相当します。

**論理ファイル（Logical File）**: 物理ファイルのデータに対するビュー（視点）を定義するファイルです。SQLのビューに相当します。

**ソースファイル（Source File）**: プログラムのソースコードを格納するファイルです。複数のメンバーを持つことができ、各メンバーが個別のソースプログラムに対応します。

**ファイルの作成**

**物理ファイルの作成（DDS使用）**

```
CRTPF FILE(TESTLIB/CUSTOMER) SRCFILE(TESTLIB/QDDSSRC) SRCMBR(CUSTOMER)
```

このコマンドで、DDSソースから物理ファイルを作成します。事前にDDSソースを作成しておく必要があります。

**物理ファイルの作成（SQL使用）**

```
RUNSQLSTM SRCFILE(TESTLIB/QSQLSRC) SRCMBR(CUSTOMER)
```

SQLのCREATE TABLE文を使用してファイルを作成することも可能です。

**ファイルの内容表示**

```
DSPPFM FILE(TESTLIB/CUSTOMER)
```

このコマンドで、ファイルの内容を表示します。Web系システムの`cat`や`less`コマンドに相当しますが、レコード指向の表示になります。

**ファイルの構造表示**

```
DSPFFD FILE(TESTLIB/CUSTOMER)
```

ファイルのフィールド定義（構造）を表示します。SQLの`DESCRIBE`文に相当します。

**ファイルのコピー**

```
CPYF FROMFILE(SOURCELIB/CUSTOMER) TOFILE(TESTLIB/CUSTOMER) MBROPT(*REPLACE)
```

ファイルの内容を別のファイルにコピーします。MBROPTパラメータで、既存データの処理方法を指定します。

**ファイルのクリア**

```
CLRPFM FILE(TESTLIB/CUSTOMER) MBR(*ALL)
```

ファイルの内容をすべて削除します。ファイル構造は残り、データのみが削除されます。

**ファイルの削除**

```
DLTF FILE(TESTLIB/CUSTOMER)
```

ファイルを完全に削除します。構造とデータの両方が削除されます。

**メンバーの管理**

IBM iのファイルは、「メンバー」という単位でデータを管理できます。1つのファイルに複数のメンバーを持つことができ、それぞれ独立したデータセットとして扱われます。

**メンバーの追加**

```
ADDPFM FILE(TESTLIB/CUSTOMER) MBR(BACKUP) TEXT('Backup Data')
```

既存のファイルに新しいメンバーを追加します。

**メンバーの一覧表示**

```
DSPFD FILE(TESTLIB/CUSTOMER) TYPE(*MBR)
```

ファイルのメンバー一覧を表示します。

**メンバーの削除**

```
RMVM FILE(TESTLIB/CUSTOMER) MBR(BACKUP)
```

指定したメンバーを削除します。

**ファイルの権限管理**

IBM iでは、オブジェクトレベルでの詳細な権限管理が可能です。

**権限の表示**

```
DSPOBJAUT OBJ(TESTLIB/CUSTOMER) OBJTYPE(*FILE)
```

ファイルの権限設定を表示します。

**権限の付与**

```
GRTOBJAUT OBJ(TESTLIB/CUSTOMER) OBJTYPE(*FILE) USER(USERNAME) AUT(*USE)
```

指定したユーザーにファイルの使用権限を付与します。

**権限の取り消し**

```
RVKOBJAUT OBJ(TESTLIB/CUSTOMER) OBJTYPE(*FILE) USER(USERNAME) AUT(*USE)
```

指定したユーザーからファイルの使用権限を取り消します。

### 5.4 ジョブとプロセスの管理

IBM iでは、実行中のプログラムやタスクを「ジョブ」と呼びます。Web系システムの「プロセス」に相当しますが、より高度な管理機能を提供しています。

**ジョブの種類**

IBM iには、以下のような種類のジョブがあります。

**対話型ジョブ（Interactive Job）**: ユーザーが5250端末から実行するジョブです。Web系システムのインタラクティブシェルに相当します。

**バッチジョブ（Batch Job）**: バックグラウンドで実行されるジョブです。Web系システムのバックグラウンドプロセスやcronジョブに相当します。

**システムジョブ（System Job）**: システムが自動的に実行するジョブです。Web系システムのデーモンプロセスに相当します。

**通信ジョブ（Communications Job）**: ネットワーク通信を処理するジョブです。

**アクティブジョブの表示**

```
WRKACTJOB
```

このコマンドで、現在実行中のすべてのジョブを表示します。Web系システムの`ps`コマンドに相当しますが、より詳細な情報が表示されます。

表示される情報には以下が含まれます。
- ジョブ名
- ユーザー名
- ジョブ番号
- ジョブタイプ
- 状態（実行中、待機中など）
- CPU使用率
- メモリ使用量

**特定ユーザーのジョブ表示**

```
WRKACTJOB SBS(*ALL) JOB(*ALL) USER(USERNAME)
```

指定したユーザーのジョブのみを表示します。

**ジョブの詳細情報表示**

```
WRKJOB JOB(jobnumber/username/jobname)
```

特定のジョブの詳細情報を表示します。ジョブの実行履歴、使用リソース、実行中のプログラムなどが確認できます。

**ジョブの終了**

```
ENDJOB JOB(jobnumber/username/jobname) OPTION(*IMMED)
```

指定したジョブを強制終了します。Web系システムの`kill`コマンドに相当します。

OPTIONパラメータで終了方法を指定できます。
- `*CNTRLD`: 制御された終了（デフォルト）
- `*IMMED`: 即座に終了
- `*FRCFAIL`: 強制的に異常終了

**バッチジョブの投入**

```
SBMJOB CMD(CALL PGM(TESTLIB/MYPGM)) JOB(BATCHJOB) JOBQ(QBATCH)
```

バッチジョブを投入します。Web系システムの`nohup`やcronに相当します。

**ジョブキューの管理**

IBM iでは、バッチジョブは「ジョブキュー」で管理されます。

**ジョブキューの状況表示**

```
WRKJOBQ JOBQ(QBATCH)
```

指定したジョブキューの状況を表示します。待機中のジョブや実行中のジョブが確認できます。

**ジョブキューの開始/停止**

```
STRJOBQ JOBQ(QBATCH)    # ジョブキューの開始
ENDJOBQ JOBQ(QBATCH)    # ジョブキューの停止
```

**サブシステムの管理**

IBM iでは、ジョブは「サブシステム」という環境で実行されます。サブシステムは、ジョブの実行環境を定義し、リソースの割り当てを管理します。

**アクティブサブシステムの表示**

```
WRKACTJOB SBS(*ALL)
```

または

```
WRKSBS
```

**サブシステムの開始/停止**

```
STRSBS SBSD(QINTER)     # サブシステムの開始
ENDSBS SBS(QINTER)      # サブシステムの停止
```

**ジョブログの確認**

IBM iでは、各ジョブの実行履歴が「ジョブログ」として記録されます。

**ジョブログの表示**

```
DSPJOBLOG JOB(jobnumber/username/jobname)
```

指定したジョブのジョブログを表示します。エラーメッセージや実行したコマンドの履歴が確認できます。

**現在のジョブのジョブログ表示**

```
DSPJOBLOG
```

パラメータを省略すると、現在のジョブのジョブログが表示されます。

**システムリソースの監視**

**システム状況の表示**

```
WRKSYSSTS
```

システム全体のリソース使用状況を表示します。CPU使用率、メモリ使用量、ディスク使用量などが確認できます。

**ディスク使用量の表示**

```
WRKSYSSTS OPTION(*DISK)
```

ディスクの使用状況を詳細に表示します。

**メモリ使用量の表示**

```
WRKSYSSTS OPTION(*POOL)
```

メモリプールの使用状況を表示します。

これらのコマンドを習得することで、IBM iシステムの基本的な操作と管理が可能になります。Web系エンジニアの方にとっては、最初は戸惑うかもしれませんが、概念を理解すれば効率的にシステムを操作できるようになります。

次の章では、実際にプログラムを作成し、実行する方法について学習していきます。


## 第6章：プログラミング入門

### 6.1 RPG言語の基礎

RPG（Report Program Generator）は、IBM iの代表的なプログラミング言語です。Web系エンジニアの方には馴染みがないかもしれませんが、ビジネスアプリケーションの開発に特化した強力な言語です。

**RPGの特徴**

RPGは、以下のような特徴を持つ言語です。

**ビジネス指向**: 会計、在庫管理、給与計算など、ビジネスアプリケーションの開発に最適化されています。

**データベース統合**: DB2 for iとの統合が深く、SQLを埋め込んで使用できます。

**高い生産性**: 少ないコードで複雑なビジネスロジックを実装できます。

**下位互換性**: 古いバージョンのRPGプログラムも現在のシステムで動作します。

**現代的な機能**: オブジェクト指向プログラミング、Webサービス、JSONサポートなど、現代的な機能も提供されています。

**RPGのバージョン**

RPGには、以下のようなバージョンがあります。

| バージョン | 特徴 | 現在の状況 |
|------------|------|------------|
| RPG II | 固定形式、基本的な機能 | レガシー |
| RPG III | 拡張された機能 | レガシー |
| RPG/400 | AS/400向けに拡張 | レガシー |
| ILE RPG | モジュラープログラミング対応 | 現役 |
| RPG IV | 自由形式、現代的な構文 | 推奨 |

現在の開発では、RPG IVまたはILE RPGを使用することが推奨されています。

**最初のRPGプログラム**

まず、簡単な「Hello World」プログラムを作成してみましょう。

**ステップ1: ソースファイルの作成**

```
CRTSRCPF FILE(TESTLIB/QRPGSRC) TEXT('RPG Source File')
```

**ステップ2: ソースメンバーの作成**

```
STRSEU SRCFILE(TESTLIB/QRPGSRC) SRCMBR(HELLO) TYPE(RPGLE)
```

**ステップ3: プログラムソースの入力**

```rpg
**FREE
// Hello World プログラム
ctl-opt dftactgrp(*no) actgrp(*caller);

dcl-s message varchar(50);

message = 'Hello, IBM i World!';
dsply message;

*inlr = *on;
```

**ステップ4: プログラムのコンパイル**

```
CRTRPGMOD MODULE(TESTLIB/HELLO) SRCFILE(TESTLIB/QRPGSRC)
CRTPGM PGM(TESTLIB/HELLO) MODULE(TESTLIB/HELLO)
```

**ステップ5: プログラムの実行**

```
CALL PGM(TESTLIB/HELLO)
```

**RPGの基本構文**

**変数の宣言**

```rpg
// 文字列変数
dcl-s customerName varchar(50);
dcl-s address char(100);

// 数値変数
dcl-s customerNumber packed(7: 0);
dcl-s amount packed(15: 2);

// 日付変数
dcl-s orderDate date;
dcl-s currentTime timestamp;

// 論理変数
dcl-s isActive ind;
```

**制御構造**

```rpg
// IF文
if customerNumber > 0;
  // 処理
elseif customerNumber = 0;
  // 処理
else;
  // 処理
endif;

// FOR文
for i = 1 to 10;
  // 処理
endfor;

// DOW文（While文）
dow customerNumber > 0;
  // 処理
  customerNumber -= 1;
enddo;

// SELECT文（Switch文）
select;
  when status = 'A';
    // アクティブな場合の処理
  when status = 'I';
    // 非アクティブな場合の処理
  other;
    // その他の場合の処理
endsl;
```

**プロシージャの定義**

```rpg
// プロシージャのプロトタイプ宣言
dcl-pr calculateTax packed(15: 2);
  amount packed(15: 2) const;
  taxRate packed(5: 4) const;
end-pr;

// プロシージャの実装
dcl-proc calculateTax;
  dcl-pi *n packed(15: 2);
    amount packed(15: 2) const;
    taxRate packed(5: 4) const;
  end-pi;
  
  return amount * taxRate;
end-proc;
```

### 6.2 CL（Control Language）プログラミング

CL（Control Language）は、IBM iのシステム制御とジョブ制御を行うためのプログラミング言語です。Web系システムのシェルスクリプトに相当しますが、より構造化された言語です。

**CLプログラムの作成**

**ステップ1: CLソースの作成**

```
STRSEU SRCFILE(TESTLIB/QCLSRC) SRCMBR(BACKUP) TYPE(CLP)
```

**ステップ2: CLプログラムソースの入力**

```cl
PGM

/* バックアップ処理プログラム */
DCL VAR(&LIBNAME) TYPE(*CHAR) LEN(10)
DCL VAR(&SAVFILE) TYPE(*CHAR) LEN(10)
DCL VAR(&MSGDTA) TYPE(*CHAR) LEN(50)

/* パラメータの受け取り */
CHGVAR VAR(&LIBNAME) VALUE('TESTLIB')
CHGVAR VAR(&SAVFILE) VALUE('BACKUP')

/* ライブラリの保存 */
MONITOR
  SAVLIB LIB(&LIBNAME) DEV(*SAVF) SAVF(QGPL/&SAVFILE)
  CHGVAR VAR(&MSGDTA) VALUE('バックアップが完了しました')
  SNDPGMMSG MSG(&MSGDTA)
ON-ERROR
  CHGVAR VAR(&MSGDTA) VALUE('バックアップでエラーが発生しました')
  SNDPGMMSG MSG(&MSGDTA) MSGTYPE(*ESCAPE)
ENDMON

ENDPGM
```

**ステップ3: CLプログラムのコンパイル**

```
CRTCLPGM PGM(TESTLIB/BACKUP) SRCFILE(TESTLIB/QCLSRC)
```

**CLの基本構文**

**変数の宣言と操作**

```cl
/* 変数の宣言 */
DCL VAR(&COUNTER) TYPE(*DEC) LEN(5 0)
DCL VAR(&MESSAGE) TYPE(*CHAR) LEN(50)
DCL VAR(&LOGDATE) TYPE(*CHAR) LEN(8)

/* 変数への値の設定 */
CHGVAR VAR(&COUNTER) VALUE(1)
CHGVAR VAR(&MESSAGE) VALUE('処理開始')
CHGVAR VAR(&LOGDATE) VALUE(%CHAR(%DATE()))
```

**条件分岐**

```cl
/* IF文 */
IF COND(&COUNTER *GT 0) THEN(DO)
  SNDPGMMSG MSG('カウンターは正の値です')
ENDDO
ELSE CMD(DO)
  SNDPGMMSG MSG('カウンターは0以下です')
ENDDO

/* SELECT文 */
SELECT
  WHEN COND(&STATUS *EQ 'A') THEN(DO)
    SNDPGMMSG MSG('アクティブ状態です')
  ENDDO
  WHEN COND(&STATUS *EQ 'I') THEN(DO)
    SNDPGMMSG MSG('非アクティブ状態です')
  ENDDO
  OTHERWISE CMD(DO)
    SNDPGMMSG MSG('不明な状態です')
  ENDDO
ENDSELECT
```

**ループ処理**

```cl
/* GOTO文を使用したループ */
LOOP:
  IF COND(&COUNTER *LE 10) THEN(DO)
    SNDPGMMSG MSG('カウンター: ' *CAT %CHAR(&COUNTER))
    CHGVAR VAR(&COUNTER) VALUE(&COUNTER + 1)
    GOTO CMDLBL(LOOP)
  ENDDO
```

**エラーハンドリング**

```cl
/* MONITOR文を使用したエラーハンドリング */
MONITOR
  CRTLIB LIB(NEWLIB)
  SNDPGMMSG MSG('ライブラリが作成されました')
ON-ERROR
  SNDPGMMSG MSG('ライブラリの作成でエラーが発生しました') MSGTYPE(*ESCAPE)
ENDMON
```

### 6.3 埋め込みSQL

IBM iでは、RPGやCOBOLなどの言語にSQLを埋め込んで使用できます。これにより、高性能なデータベースアクセスが可能になります。

**埋め込みSQLの基本**

**SQLの埋め込み方法**

```rpg
**FREE
ctl-opt dftactgrp(*no) actgrp(*caller);

// SQL通信エリアの宣言
exec sql include sqlca;

// ホスト変数の宣言
dcl-s customerNumber packed(7: 0);
dcl-s customerName varchar(50);
dcl-s customerAddress varchar(100);

// SQLの実行
customerNumber = 12345;

exec sql
  select name, address
  into :customerName, :customerAddress
  from customer
  where custno = :customerNumber;

// エラーチェック
if sqlcode = 0;
  dsply ('顧客名: ' + customerName);
  dsply ('住所: ' + customerAddress);
else;
  dsply ('顧客が見つかりません');
endif;

*inlr = *on;
```

**カーソルを使用した複数行処理**

```rpg
**FREE
ctl-opt dftactgrp(*no) actgrp(*caller);

exec sql include sqlca;

// ホスト変数の宣言
dcl-s customerNumber packed(7: 0);
dcl-s customerName varchar(50);
dcl-s totalAmount packed(15: 2);

// カーソルの宣言
exec sql
  declare c1 cursor for
  select custno, name, sum(amount)
  from customer c
  join orders o on c.custno = o.custno
  group by custno, name
  order by sum(amount) desc;

// カーソルのオープン
exec sql open c1;

// データの取得
exec sql fetch c1 into :customerNumber, :customerName, :totalAmount;

dow sqlcode = 0;
  dsply ('顧客: ' + customerName + ' 合計: ' + %char(totalAmount));
  
  exec sql fetch c1 into :customerNumber, :customerName, :totalAmount;
enddo;

// カーソルのクローズ
exec sql close c1;

*inlr = *on;
```

**トランザクション制御**

```rpg
**FREE
ctl-opt dftactgrp(*no) actgrp(*caller);

exec sql include sqlca;

dcl-s customerNumber packed(7: 0);
dcl-s orderNumber packed(10: 0);
dcl-s amount packed(15: 2);

// トランザクション開始
exec sql set transaction isolation level read committed;

monitor;
  // 注文の挿入
  exec sql
    insert into orders (orderno, custno, amount, orderdate)
    values (:orderNumber, :customerNumber, :amount, current date);
  
  // 在庫の更新
  exec sql
    update inventory
    set quantity = quantity - 1
    where productid = :productId;
  
  // コミット
  exec sql commit;
  
  dsply '注文が正常に処理されました';

on-error;
  // ロールバック
  exec sql rollback;
  dsply '注文処理でエラーが発生しました';
endmon;

*inlr = *on;
```

## 第7章：データベース操作

### 7.1 DB2 for i の基本操作

DB2 for iは、IBM iに統合されたリレーショナルデータベース管理システムです。Web系エンジニアの方が使い慣れたMySQLやPostgreSQLと同様の機能を提供しますが、IBM i独自の特徴もあります。

**SQLの実行環境**

IBM iでは、以下の方法でSQLを実行できます。

**STRSQL（Start SQL）**: 対話型SQLインターフェース
**RUNSQLSTM（Run SQL Statement）**: SQLスクリプトの実行
**埋め込みSQL**: プログラム内でのSQL実行
**IBM i Access Client Solutions**: PC上のGUIツール

**STRSQLの使用**

```
STRSQL
```

このコマンドで対話型SQLセッションを開始します。Web系システムのmysqlクライアントやpsqlに相当します。

**基本的なSQL操作**

**テーブルの作成**

```sql
CREATE TABLE TESTLIB.CUSTOMER (
    CUSTNO DECIMAL(7,0) NOT NULL PRIMARY KEY,
    NAME VARCHAR(50) NOT NULL,
    ADDRESS VARCHAR(100),
    PHONE VARCHAR(20),
    EMAIL VARCHAR(100),
    CREATED_DATE DATE DEFAULT CURRENT DATE,
    CREATED_TIME TIMESTAMP DEFAULT CURRENT TIMESTAMP
);
```

**データの挿入**

```sql
INSERT INTO TESTLIB.CUSTOMER 
(CUSTNO, NAME, ADDRESS, PHONE, EMAIL) 
VALUES 
(1001, '田中太郎', '東京都渋谷区1-1-1', '03-1234-5678', 'tanaka@example.com'),
(1002, '佐藤花子', '大阪府大阪市2-2-2', '06-9876-5432', 'sato@example.com'),
(1003, '鈴木一郎', '愛知県名古屋市3-3-3', '052-1111-2222', 'suzuki@example.com');
```

**データの検索**

```sql
-- 全件検索
SELECT * FROM TESTLIB.CUSTOMER;

-- 条件付き検索
SELECT CUSTNO, NAME, EMAIL 
FROM TESTLIB.CUSTOMER 
WHERE NAME LIKE '%田中%';

-- 並び替え
SELECT * FROM TESTLIB.CUSTOMER 
ORDER BY CREATED_DATE DESC;

-- 集計
SELECT COUNT(*) AS CUSTOMER_COUNT,
       MIN(CREATED_DATE) AS FIRST_CUSTOMER,
       MAX(CREATED_DATE) AS LAST_CUSTOMER
FROM TESTLIB.CUSTOMER;
```

**データの更新**

```sql
-- 単一レコードの更新
UPDATE TESTLIB.CUSTOMER 
SET EMAIL = 'tanaka.new@example.com',
    ADDRESS = '東京都新宿区4-4-4'
WHERE CUSTNO = 1001;

-- 複数レコードの更新
UPDATE TESTLIB.CUSTOMER 
SET PHONE = REPLACE(PHONE, '-', '')
WHERE PHONE LIKE '%-%';
```

**データの削除**

```sql
-- 条件付き削除
DELETE FROM TESTLIB.CUSTOMER 
WHERE CREATED_DATE < CURRENT DATE - 1 YEAR;

-- 全件削除（注意！）
DELETE FROM TESTLIB.CUSTOMER;
```

### 7.2 高度なSQL機能

DB2 for iは、標準的なSQL機能に加えて、多くの高度な機能を提供しています。

**ウィンドウ関数**

```sql
-- 売上ランキング
SELECT 
    CUSTNO,
    NAME,
    TOTAL_AMOUNT,
    ROW_NUMBER() OVER (ORDER BY TOTAL_AMOUNT DESC) AS RANK,
    PERCENT_RANK() OVER (ORDER BY TOTAL_AMOUNT DESC) AS PERCENTILE
FROM (
    SELECT 
        c.CUSTNO,
        c.NAME,
        SUM(o.AMOUNT) AS TOTAL_AMOUNT
    FROM TESTLIB.CUSTOMER c
    JOIN TESTLIB.ORDERS o ON c.CUSTNO = o.CUSTNO
    GROUP BY c.CUSTNO, c.NAME
) AS CUSTOMER_SALES;

-- 移動平均
SELECT 
    ORDER_DATE,
    AMOUNT,
    AVG(AMOUNT) OVER (
        ORDER BY ORDER_DATE 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS MOVING_AVERAGE
FROM TESTLIB.ORDERS
ORDER BY ORDER_DATE;
```

**共通テーブル式（CTE）**

```sql
-- 再帰CTE（組織階層の表示）
WITH RECURSIVE ORG_HIERARCHY (EMPNO, NAME, MANAGER, LEVEL, PATH) AS (
    -- アンカー：トップレベルの従業員
    SELECT EMPNO, NAME, MANAGER, 1, CAST(NAME AS VARCHAR(1000))
    FROM TESTLIB.EMPLOYEE
    WHERE MANAGER IS NULL
    
    UNION ALL
    
    -- 再帰：部下の従業員
    SELECT e.EMPNO, e.NAME, e.MANAGER, h.LEVEL + 1, 
           h.PATH || ' -> ' || e.NAME
    FROM TESTLIB.EMPLOYEE e
    JOIN ORG_HIERARCHY h ON e.MANAGER = h.EMPNO
)
SELECT EMPNO, NAME, LEVEL, PATH
FROM ORG_HIERARCHY
ORDER BY LEVEL, NAME;
```

**JSON サポート**

```sql
-- JSONデータの挿入
CREATE TABLE TESTLIB.PRODUCT_INFO (
    PRODUCT_ID INT,
    PRODUCT_DATA JSON
);

INSERT INTO TESTLIB.PRODUCT_INFO VALUES 
(1, '{"name": "ノートPC", "price": 98000, "specs": {"cpu": "Intel i7", "memory": "16GB"}}'),
(2, '{"name": "スマートフォン", "price": 78000, "specs": {"os": "Android", "storage": "128GB"}}');

-- JSONデータの検索
SELECT 
    PRODUCT_ID,
    JSON_VALUE(PRODUCT_DATA, '$.name') AS PRODUCT_NAME,
    JSON_VALUE(PRODUCT_DATA, '$.price') AS PRICE,
    JSON_VALUE(PRODUCT_DATA, '$.specs.cpu') AS CPU
FROM TESTLIB.PRODUCT_INFO
WHERE JSON_VALUE(PRODUCT_DATA, '$.price') > 80000;
```

**テンポラルテーブル（履歴管理）**

```sql
-- システム期間テーブルの作成
CREATE TABLE TESTLIB.CUSTOMER_HISTORY (
    CUSTNO DECIMAL(7,0) NOT NULL,
    NAME VARCHAR(50) NOT NULL,
    ADDRESS VARCHAR(100),
    SYS_START TIMESTAMP(12) GENERATED ALWAYS AS ROW BEGIN NOT NULL,
    SYS_END TIMESTAMP(12) GENERATED ALWAYS AS ROW END NOT NULL,
    TRANS_START TIMESTAMP(12) GENERATED ALWAYS AS TRANSACTION START ID NOT NULL,
    PERIOD SYSTEM_TIME (SYS_START, SYS_END),
    PRIMARY KEY (CUSTNO, SYS_START)
) WITH SYSTEM VERSIONING;

-- 履歴データの検索
SELECT * FROM TESTLIB.CUSTOMER_HISTORY
FOR SYSTEM_TIME AS OF '2024-01-01-12.00.00.000000'
WHERE CUSTNO = 1001;

-- 期間内の変更履歴
SELECT * FROM TESTLIB.CUSTOMER_HISTORY
FOR SYSTEM_TIME BETWEEN '2024-01-01' AND '2024-12-31'
WHERE CUSTNO = 1001;
```

### 7.3 パフォーマンス最適化

DB2 for iでは、クエリのパフォーマンスを最適化するための様々な機能が提供されています。

**インデックスの作成と管理**

```sql
-- 基本的なインデックス
CREATE INDEX TESTLIB.IDX_CUSTOMER_NAME 
ON TESTLIB.CUSTOMER (NAME);

-- 複合インデックス
CREATE INDEX TESTLIB.IDX_ORDERS_CUSTNO_DATE 
ON TESTLIB.ORDERS (CUSTNO, ORDER_DATE);

-- 部分インデックス
CREATE INDEX TESTLIB.IDX_ACTIVE_CUSTOMERS 
ON TESTLIB.CUSTOMER (CUSTNO) 
WHERE STATUS = 'A';

-- 関数ベースインデックス
CREATE INDEX TESTLIB.IDX_CUSTOMER_UPPER_NAME 
ON TESTLIB.CUSTOMER (UPPER(NAME));
```

**統計情報の管理**

```sql
-- 統計情報の更新
CALL QSYS2.GATHER_TABLE_STATS('TESTLIB', 'CUSTOMER');

-- 統計情報の確認
SELECT * FROM QSYS2.SYSTABLESTAT 
WHERE TABLE_SCHEMA = 'TESTLIB' 
AND TABLE_NAME = 'CUSTOMER';
```

**クエリプランの確認**

```sql
-- Visual Explainの使用
CALL QSYS2.DUMP_PLAN_CACHE();

-- プランキャッシュの確認
SELECT * FROM QSYS2.PLAN_CACHE 
WHERE SQL_STATEMENT LIKE '%CUSTOMER%';
```

**パーティショニング**

```sql
-- レンジパーティショニング
CREATE TABLE TESTLIB.SALES_HISTORY (
    SALE_ID BIGINT,
    SALE_DATE DATE,
    AMOUNT DECIMAL(15,2),
    CUSTOMER_ID INT
) 
PARTITION BY RANGE (SALE_DATE) (
    PARTITION P2023 VALUES LESS THAN ('2024-01-01'),
    PARTITION P2024 VALUES LESS THAN ('2025-01-01'),
    PARTITION P2025 VALUES LESS THAN ('2026-01-01')
);
```

これらの機能を活用することで、IBM iでの効率的なデータベース操作が可能になります。Web系エンジニアの方にとっては、既存のSQL知識を活かしながら、IBM i特有の機能を学習できるでしょう。

次の章では、より高度な開発技術と現代的な開発手法について学習していきます。


---

# 第3部：応用・モダン化編

## 第8章：現代的な開発環境

### 8.1 VS Code + Code for IBM i

従来のIBM i開発では、5250端末やSEU（Source Entry Utility）を使用していましたが、現在では現代的な開発環境も利用できるようになっています。特に、Visual Studio Code（VS Code）とCode for IBM i拡張機能の組み合わせは、Web系エンジニアにとって馴染みやすい開発環境を提供します。

**Code for IBM i の特徴**

Code for IBM iは、VS Code上でIBM i開発を行うための拡張機能です。以下のような特徴があります。

**現代的なエディタ機能**: シンタックスハイライト、コード補完、エラー検出、リファクタリングなど、現代的なエディタ機能をすべて利用できます。

**統合開発環境**: ソース編集、コンパイル、デバッグ、ファイル管理をすべてVS Code内で実行できます。

**Git統合**: Gitによるバージョン管理が標準でサポートされており、ブランチ管理、マージ、プルリクエストなどの現代的な開発フローを利用できます。

**リモート開発**: SSH接続によりリモートのIBM iシステムに接続し、ローカルPCから開発作業を行えます。

**マルチプラットフォーム**: Windows、macOS、Linuxで動作します。

**セットアップ手順**

**ステップ1: VS Codeのインストール**

公式サイト（https://code.visualstudio.com/）からVS Codeをダウンロードしてインストールします。

**ステップ2: Code for IBM i拡張機能のインストール**

VS Codeの拡張機能マーケットプレイスから「Code for IBM i」を検索してインストールします。

**ステップ3: IBM iシステムへの接続設定**

1. VS Codeでコマンドパレット（Ctrl+Shift+P）を開く
2. 「IBM i: Connect」を選択
3. 接続情報を入力：
   - Host: PUB400.COM
   - Username: 登録したユーザーID
   - Password: パスワード
   - Port: 22（SSH）

**ステップ4: ライブラリとソースファイルの設定**

接続後、作業するライブラリとソースファイルを設定します。

**基本的な使用方法**

**ソースメンバーの編集**

1. IBM i Explorerでライブラリを展開
2. ソースファイル（例：QRPGSRC）を展開
3. 編集したいメンバーをダブルクリック
4. VS Codeのエディタでソースを編集
5. Ctrl+Sで保存（自動的にIBM iシステムに保存される）

**コンパイル**

1. ソースメンバーを開いた状態で右クリック
2. 「Compile」を選択
3. コンパイル結果がターミナルに表示される

**デバッグ**

1. プログラムにブレークポイントを設定
2. F5キーでデバッグ開始
3. 変数の値確認、ステップ実行などが可能

**Gitとの統合**

Code for IBM iでは、IBM iのソースコードをGitで管理できます。

**初期設定**

```bash
# ローカルリポジトリの初期化
git init

# IBM iソースの追加
git add .

# 初回コミット
git commit -m "Initial commit"

# リモートリポジトリの設定
git remote add origin https://github.com/username/ibmi-project.git
git push -u origin main
```

**開発フロー**

```bash
# 新機能の開発
git checkout -b feature/new-customer-function

# 開発作業（VS Code上でソース編集）
# ...

# 変更をコミット
git add .
git commit -m "Add new customer function"

# リモートにプッシュ
git push origin feature/new-customer-function

# プルリクエスト作成（GitHub/GitLab等）
```

### 8.2 RDi（Rational Developer for i）

RDi（Rational Developer for i）は、IBMが提供するIBM i専用の統合開発環境です。Eclipseベースで構築されており、Java開発者には馴染みやすい環境です。

**RDiの特徴**

**Eclipse基盤**: Javaエンジニアが慣れ親しんだEclipseをベースとしているため、学習コストが低くなります。

**高度なデバッグ機能**: ソースレベルデバッグ、ウォッチポイント、条件付きブレークポイントなど、高度なデバッグ機能を提供します。

**プロジェクト管理**: 複数のライブラリやソースファイルを統合的に管理できます。

**コード分析**: 静的コード分析、依存関係分析、影響分析などの機能があります。

**チーム開発支援**: CVS、Subversion、Gitなどのバージョン管理システムとの統合が可能です。

**主要機能**

**ソースエディタ**

- シンタックスハイライト
- コード補完（Content Assist）
- エラー検出とクイックフィックス
- リファクタリング
- コードテンプレート

**デバッガ**

- ソースレベルデバッグ
- 変数ウォッチ
- コールスタック表示
- メモリビュー
- 条件付きブレークポイント

**プロジェクト管理**

- ライブラリ管理
- ソースファイル管理
- 依存関係管理
- ビルド設定

**コード分析**

- 静的コード分析
- 複雑度測定
- 未使用変数検出
- 依存関係分析

### 8.3 IBM i Access Client Solutions

IBM i Access Client Solutions（ACS）は、IBM iシステムにアクセスするためのクライアントツール集です。Web系エンジニアにとって、GUIベースの管理ツールとして有用です。

**主要機能**

**5250エミュレータ**

従来の5250端末エミュレータ機能に加えて、以下の機能があります。

- マクロ記録・再生
- 画面印刷・保存
- ファイル転送
- 複数セッション管理

**Run SQL Scripts**

GUIベースのSQL実行環境です。

- SQLエディタ（シンタックスハイライト付き）
- 結果セットの表示・エクスポート
- 実行プランの表示
- SQLスクリプトの保存・管理

**Schema Browser**

データベーススキーマをGUIで参照できます。

- テーブル構造の表示
- インデックス情報の表示
- 制約情報の表示
- データのプレビュー

**System Debugger**

GUIベースのデバッグ環境です。

- ソースレベルデバッグ
- 変数の監視
- ブレークポイント管理
- コールスタック表示

**Data Transfer**

データのインポート・エクスポート機能です。

- CSV、Excel、XMLなどの形式をサポート
- データ変換機能
- スケジュール実行

### 8.4 CI/CD パイプラインの構築

現代的なソフトウェア開発では、CI/CD（継続的インテグレーション・継続的デプロイメント）が重要です。IBM i環境でも、これらの手法を適用できます。

**IBM i でのCI/CD の課題と解決策**

**課題1: ソースコード管理**

従来のIBM i開発では、ソースコードがIBM iシステム上のソースファイルに格納されており、外部のバージョン管理システムとの統合が困難でした。

**解決策**: 
- Code for IBM iやRDiを使用してGitとの統合を実現
- ソースコードをGitリポジトリで管理
- IBM iシステムとの同期を自動化

**課題2: 自動ビルド**

IBM iのコンパイルは、システム上で実行する必要があり、外部のCI/CDツールからの実行が困難でした。

**解決策**:
- SSH経由でのリモートコンパイル
- CLプログラムによるビルドスクリプトの作成
- Jenkins、GitHub Actions等のCI/CDツールとの統合

**課題3: テスト自動化**

IBM iでは、自動テストの仕組みが限られていました。

**解決策**:
- iUnit（IBM i用単体テストフレームワーク）の活用
- SQLベースのデータテスト
- 外部システムとの統合テスト

**CI/CDパイプラインの例**

**GitHub Actions を使用した例**

```yaml
name: IBM i CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.5.3
      with:
        ssh-private-key: ${{ secrets.IBM_I_SSH_KEY }}
    
    - name: Deploy Source to IBM i
      run: |
        scp -r ./src/* user@ibmi-server:/QSYS.LIB/DEVLIB.LIB/QRPGSRC.FILE/
    
    - name: Compile Programs
      run: |
        ssh user@ibmi-server "system 'CRTPGM PGM(DEVLIB/MYPGM) SRCFILE(DEVLIB/QRPGSRC)'"
    
    - name: Run Tests
      run: |
        ssh user@ibmi-server "system 'CALL PGM(TESTLIB/RUNTESTS)'"
    
    - name: Deploy to Production
      if: github.ref == 'refs/heads/main'
      run: |
        ssh user@ibmi-server "system 'CPYOBJ FROMOBJ(DEVLIB/MYPGM) OBJTYPE(*PGM) TOLIB(PRODLIB)'"
```

**Jenkins を使用した例**

```groovy
pipeline {
    agent any
    
    stages {
        stage('Checkout') {
            steps {
                git 'https://github.com/company/ibmi-project.git'
            }
        }
        
        stage('Deploy Source') {
            steps {
                script {
                    sh '''
                        scp -r ./src/* user@ibmi-server:/QSYS.LIB/DEVLIB.LIB/QRPGSRC.FILE/
                    '''
                }
            }
        }
        
        stage('Compile') {
            steps {
                script {
                    sh '''
                        ssh user@ibmi-server "system 'CALL DEVLIB/BUILDALL'"
                    '''
                }
            }
        }
        
        stage('Test') {
            steps {
                script {
                    sh '''
                        ssh user@ibmi-server "system 'CALL TESTLIB/RUNTESTS'"
                    '''
                }
            }
        }
        
        stage('Deploy') {
            when {
                branch 'main'
            }
            steps {
                script {
                    sh '''
                        ssh user@ibmi-server "system 'CALL DEVLIB/DEPLOY'"
                    '''
                }
            }
        }
    }
    
    post {
        always {
            archiveArtifacts artifacts: 'logs/**', allowEmptyArchive: true
        }
        failure {
            emailext (
                subject: "Build Failed: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                body: "Build failed. Check console output at ${env.BUILD_URL}",
                to: "${env.CHANGE_AUTHOR_EMAIL}"
            )
        }
    }
}
```

**ビルドスクリプトの例（CL）**

```cl
PGM

/* ビルドスクリプト */
DCL VAR(&SRCLIB) TYPE(*CHAR) LEN(10) VALUE('DEVLIB')
DCL VAR(&SRCFILE) TYPE(*CHAR) LEN(10) VALUE('QRPGSRC')
DCL VAR(&PGMLIB) TYPE(*CHAR) LEN(10) VALUE('DEVLIB')

MONITOR
  /* RPGプログラムのコンパイル */
  CRTRPGMOD MODULE(&PGMLIB/CUSTOMER) SRCFILE(&SRCLIB/&SRCFILE) SRCMBR(CUSTOMER)
  CRTPGM PGM(&PGMLIB/CUSTOMER) MODULE(&PGMLIB/CUSTOMER)
  
  CRTRPGMOD MODULE(&PGMLIB/ORDER) SRCFILE(&SRCLIB/&SRCFILE) SRCMBR(ORDER)
  CRTPGM PGM(&PGMLIB/ORDER) MODULE(&PGMLIB/ORDER)
  
  /* サービスプログラムのコンパイル */
  CRTRPGMOD MODULE(&PGMLIB/UTILS) SRCFILE(&SRCLIB/&SRCFILE) SRCMBR(UTILS)
  CRTSRVPGM SRVPGM(&PGMLIB/UTILS) MODULE(&PGMLIB/UTILS)
  
  SNDPGMMSG MSG('ビルドが正常に完了しました')

ON-ERROR
  SNDPGMMSG MSG('ビルドでエラーが発生しました') MSGTYPE(*ESCAPE)
ENDMON

ENDPGM
```

## 第9章：モダン化とレガシー統合

### 9.1 レガシーシステムのモダン化戦略

多くの企業では、長年にわたって蓄積されたIBM iのレガシーシステムが稼働しています。これらのシステムをモダン化することは、ビジネスの競争力向上と技術的負債の解消において重要です。

**モダン化のアプローチ**

**段階的モダン化（Incremental Modernization）**

一度にすべてを変更するのではなく、段階的にモダン化を進めるアプローチです。

**フェーズ1: インターフェースのモダン化**
- 5250画面をWebインターフェースに置き換え
- 既存のビジネスロジックは維持
- ユーザーエクスペリエンスの向上

**フェーズ2: アーキテクチャのモダン化**
- モノリシックなプログラムをサービス指向に分割
- APIの導入
- データアクセス層の抽象化

**フェーズ3: 技術スタックのモダン化**
- 新しいプログラミング言語の導入（Java、Node.js等）
- クラウドサービスとの統合
- マイクロサービス化

**ストラングラーパターン（Strangler Pattern）**

新しいシステムで古いシステムを徐々に置き換えていくパターンです。

```
[クライアント] → [プロキシ/ゲートウェイ] → [新システム]
                                        → [旧システム]
```

プロキシが要求を適切なシステムにルーティングし、段階的に新システムに移行します。

**APIファーストアプローチ**

既存のビジネスロジックをAPIとして公開し、新しいフロントエンドから利用するアプローチです。

**RPGプログラムのWebサービス化**

既存のRPGプログラムをWebサービスとして公開する例：

```rpg
**FREE
ctl-opt dftactgrp(*no) actgrp(*caller);

// Webサービスのプロトタイプ
dcl-pr getCustomerInfo;
  customerNo packed(7: 0) const;
  customerData varchar(1000);
end-pr;

// Webサービスの実装
dcl-proc getCustomerInfo export;
  dcl-pi *n;
    customerNo packed(7: 0) const;
    customerData varchar(1000);
  end-pi;
  
  dcl-s name varchar(50);
  dcl-s address varchar(100);
  dcl-s phone varchar(20);
  
  // 既存のビジネスロジック
  exec sql
    select name, address, phone
    into :name, :address, :phone
    from customer
    where custno = :customerNo;
  
  if sqlcode = 0;
    // JSONレスポンスの生成
    customerData = '{"custno":' + %char(customerNo) + 
                   ',"name":"' + %trim(name) + '"' +
                   ',"address":"' + %trim(address) + '"' +
                   ',"phone":"' + %trim(phone) + '"}';
  else;
    customerData = '{"error":"Customer not found"}';
  endif;
end-proc;
```

**RESTful API の実装**

IBM i上でRESTful APIを実装する方法：

**ILE RPG + IWS（Integrated Web Services）**

```rpg
**FREE
ctl-opt dftactgrp(*no) actgrp(*caller);

// HTTP ヘッダーの設定
dcl-pr setHttpHeader;
  header varchar(100) const;
  value varchar(100) const;
end-pr;

// RESTエンドポイントの実装
dcl-proc handleCustomerRequest export;
  dcl-pi *n;
    method varchar(10) const;
    path varchar(100) const;
    requestBody varchar(1000) const;
    responseBody varchar(1000);
  end-pi;
  
  dcl-s customerNo packed(7: 0);
  
  // Content-Typeの設定
  setHttpHeader('Content-Type' : 'application/json');
  
  select;
    when method = 'GET';
      // パスからカスタマー番号を抽出
      customerNo = %int(%subst(path : %scan('/customers/' : path) + 11));
      responseBody = getCustomerInfo(customerNo);
      
    when method = 'POST';
      // 新規顧客の作成
      responseBody = createCustomer(requestBody);
      
    when method = 'PUT';
      // 顧客情報の更新
      customerNo = %int(%subst(path : %scan('/customers/' : path) + 11));
      responseBody = updateCustomer(customerNo : requestBody);
      
    when method = 'DELETE';
      // 顧客の削除
      customerNo = %int(%subst(path : %scan('/customers/' : path) + 11));
      responseBody = deleteCustomer(customerNo);
      
    other;
      responseBody = '{"error":"Method not allowed"}';
  endsl;
end-proc;
```

### 9.2 マイクロサービス化

モノリシックなIBM iアプリケーションをマイクロサービスに分割することで、保守性、スケーラビリティ、開発効率を向上させることができます。

**マイクロサービス分割の戦略**

**ドメイン駆動設計（DDD）による分割**

ビジネスドメインに基づいてサービスを分割します。

```
顧客管理サービス
├── 顧客情報管理
├── 顧客認証
└── 顧客履歴

注文管理サービス
├── 注文処理
├── 在庫確認
└── 配送管理

請求管理サービス
├── 請求書生成
├── 支払い処理
└── 会計連携
```

**データベースの分離**

各マイクロサービスが独自のデータベースを持つように設計します。

```sql
-- 顧客サービス用データベース
CREATE SCHEMA CUSTOMER_SERVICE;
CREATE TABLE CUSTOMER_SERVICE.CUSTOMERS (...);
CREATE TABLE CUSTOMER_SERVICE.CUSTOMER_PROFILES (...);

-- 注文サービス用データベース
CREATE SCHEMA ORDER_SERVICE;
CREATE TABLE ORDER_SERVICE.ORDERS (...);
CREATE TABLE ORDER_SERVICE.ORDER_ITEMS (...);

-- 請求サービス用データベース
CREATE SCHEMA BILLING_SERVICE;
CREATE TABLE BILLING_SERVICE.INVOICES (...);
CREATE TABLE BILLING_SERVICE.PAYMENTS (...);
```

**サービス間通信**

**同期通信（REST API）**

```rpg
// 注文サービスから顧客サービスを呼び出し
dcl-proc validateCustomer;
  dcl-pi *n ind;
    customerNo packed(7: 0) const;
  end-pi;
  
  dcl-s httpResponse varchar(1000);
  dcl-s url varchar(200);
  
  url = 'http://customer-service:8080/api/customers/' + %char(customerNo);
  
  // HTTP GETリクエストの実行
  httpResponse = httpGet(url);
  
  // レスポンスの解析
  if %scan('"status":"active"' : httpResponse) > 0;
    return *on;
  else;
    return *off;
  endif;
end-proc;
```

**非同期通信（メッセージキュー）**

```rpg
// 注文完了イベントの送信
dcl-proc publishOrderCompleted;
  dcl-pi *n;
    orderNo packed(10: 0) const;
    customerNo packed(7: 0) const;
    amount packed(15: 2) const;
  end-pi;
  
  dcl-s message varchar(500);
  
  // イベントメッセージの作成
  message = '{"event":"OrderCompleted",' +
            '"orderNo":' + %char(orderNo) + ',' +
            '"customerNo":' + %char(customerNo) + ',' +
            '"amount":' + %char(amount) + ',' +
            '"timestamp":"' + %char(%timestamp()) + '"}';
  
  // メッセージキューに送信
  sendToQueue('order.events' : message);
end-proc;
```

**API Gateway の実装**

複数のマイクロサービスを統合するAPI Gatewayの実装例：

```javascript
// Node.js + Express による API Gateway
const express = require('express');
const httpProxy = require('http-proxy-middleware');
const app = express();

// 顧客サービスへのプロキシ
app.use('/api/customers', httpProxy({
  target: 'http://customer-service:8080',
  changeOrigin: true
}));

// 注文サービスへのプロキシ
app.use('/api/orders', httpProxy({
  target: 'http://order-service:8080',
  changeOrigin: true
}));

// 請求サービスへのプロキシ
app.use('/api/billing', httpProxy({
  target: 'http://billing-service:8080',
  changeOrigin: true
}));

// 認証ミドルウェア
app.use('/api/*', (req, res, next) => {
  const token = req.headers.authorization;
  if (validateToken(token)) {
    next();
  } else {
    res.status(401).json({ error: 'Unauthorized' });
  }
});

app.listen(3000, () => {
  console.log('API Gateway listening on port 3000');
});
```

### 9.3 クラウド統合

IBM iシステムをクラウドサービスと統合することで、スケーラビリティ、可用性、コスト効率を向上させることができます。

**ハイブリッドクラウド戦略**

**オンプレミス IBM i + パブリッククラウド**

```
[オンプレミス IBM i]
├── コアビジネスロジック
├── マスターデータ
└── レガシーアプリケーション

[パブリッククラウド]
├── Webフロントエンド
├── モバイルアプリ
├── 分析・レポート
└── 外部API連携
```

**データ同期の実装**

```rpg
// クラウドデータベースとの同期
dcl-proc syncToCloud;
  dcl-pi *n;
    tableName varchar(50) const;
    lastSyncTime timestamp const;
  end-pi;
  
  dcl-s jsonData varchar(32000);
  dcl-s httpResponse varchar(1000);
  
  // 変更されたデータの抽出
  exec sql
    declare c1 cursor for
    select json_object(
      'id': id,
      'data': data,
      'updated': updated_timestamp
    )
    from :tableName
    where updated_timestamp > :lastSyncTime;
  
  exec sql open c1;
  
  exec sql fetch c1 into :jsonData;
  
  dow sqlcode = 0;
    // クラウドAPIに送信
    httpResponse = httpPost('https://api.cloud-service.com/sync' : jsonData);
    
    exec sql fetch c1 into :jsonData;
  enddo;
  
  exec sql close c1;
end-proc;
```

**AWS との統合例**

**S3 へのファイルアップロード**

```rpg
// AWS S3へのファイルアップロード
dcl-proc uploadToS3;
  dcl-pi *n;
    fileName varchar(100) const;
    bucketName varchar(50) const;
  end-pi;
  
  dcl-s awsAccessKey varchar(50);
  dcl-s awsSecretKey varchar(100);
  dcl-s signature varchar(200);
  dcl-s httpHeaders varchar(500);
  
  // AWS認証情報の取得
  awsAccessKey = getConfigValue('AWS_ACCESS_KEY');
  awsSecretKey = getConfigValue('AWS_SECRET_KEY');
  
  // AWS署名の生成
  signature = generateAwsSignature(fileName : bucketName : awsSecretKey);
  
  // HTTPヘッダーの構築
  httpHeaders = 'Authorization: AWS ' + awsAccessKey + ':' + signature + CRLF +
                'Content-Type: application/octet-stream' + CRLF +
                'x-amz-acl: private';
  
  // ファイルのアップロード
  httpPutFile('https://' + bucketName + '.s3.amazonaws.com/' + fileName :
              '/tmp/' + fileName : httpHeaders);
end-proc;
```

**Lambda 関数の呼び出し**

```rpg
// AWS Lambda関数の呼び出し
dcl-proc invokeLambda;
  dcl-pi *n varchar(1000);
    functionName varchar(50) const;
    payload varchar(1000) const;
  end-pi;
  
  dcl-s url varchar(200);
  dcl-s headers varchar(300);
  dcl-s response varchar(1000);
  
  url = 'https://lambda.us-east-1.amazonaws.com/2015-03-31/functions/' +
        functionName + '/invocations';
  
  headers = 'Authorization: AWS4-HMAC-SHA256 ...' + CRLF +
            'Content-Type: application/json';
  
  response = httpPost(url : payload : headers);
  
  return response;
end-proc;
```

**Azure との統合例**

**Azure Service Bus との連携**

```rpg
// Azure Service Busへのメッセージ送信
dcl-proc sendToServiceBus;
  dcl-pi *n;
    queueName varchar(50) const;
    message varchar(1000) const;
  end-pi;
  
  dcl-s url varchar(200);
  dcl-s sasToken varchar(300);
  dcl-s headers varchar(400);
  
  // SASトークンの生成
  sasToken = generateSasToken(queueName);
  
  url = 'https://namespace.servicebus.windows.net/' + queueName + '/messages';
  
  headers = 'Authorization: SharedAccessSignature ' + sasToken + CRLF +
            'Content-Type: application/json' + CRLF +
            'BrokerProperties: {"Label":"IBMiMessage"}';
  
  httpPost(url : message : headers);
end-proc;
```

## 第10章：外部システム連携

### 10.1 Web API の作成と公開

IBM iシステムのデータとビジネスロジックを外部システムから利用できるようにするため、Web APIの作成と公開は重要な技術です。

**IWS（Integrated Web Services）を使用したAPI作成**

IBM iには、RPGプログラムを簡単にWebサービスとして公開できるIWS機能があります。

**RESTful API の実装例**

```rpg
**FREE
ctl-opt dftactgrp(*no) actgrp(*caller);

// 顧客情報取得API
dcl-proc getCustomer export;
  dcl-pi *n varchar(1000);
    customerId packed(7: 0) const;
  end-pi;
  
  dcl-s customerJson varchar(1000);
  dcl-s name varchar(50);
  dcl-s email varchar(100);
  dcl-s phone varchar(20);
  dcl-s address varchar(200);
  dcl-s status char(1);
  
  // データベースから顧客情報を取得
  exec sql
    select name, email, phone, address, status
    into :name, :email, :phone, :address, :status
    from customers
    where customer_id = :customerId;
  
  if sqlcode = 0;
    // JSON レスポンスの構築
    customerJson = '{'
      + '"customerId":' + %char(customerId) + ','
      + '"name":"' + %trim(name) + '",'
      + '"email":"' + %trim(email) + '",'
      + '"phone":"' + %trim(phone) + '",'
      + '"address":"' + %trim(address) + '",'
      + '"status":"' + status + '",'
      + '"lastUpdated":"' + %char(%timestamp()) + '"'
      + '}';
  else;
    customerJson = '{"error":"Customer not found","code":404}';
  endif;
  
  return customerJson;
end-proc;

// 顧客情報更新API
dcl-proc updateCustomer export;
  dcl-pi *n varchar(500);
    customerId packed(7: 0) const;
    customerData varchar(1000) const;
  end-pi;
  
  dcl-s responseJson varchar(500);
  dcl-s name varchar(50);
  dcl-s email varchar(100);
  dcl-s phone varchar(20);
  dcl-s address varchar(200);
  
  // JSONデータの解析
  name = extractJsonValue(customerData : 'name');
  email = extractJsonValue(customerData : 'email');
  phone = extractJsonValue(customerData : 'phone');
  address = extractJsonValue(customerData : 'address');
  
  // データベースの更新
  exec sql
    update customers
    set name = :name,
        email = :email,
        phone = :phone,
        address = :address,
        updated_timestamp = current timestamp
    where customer_id = :customerId;
  
  if sqlcode = 0;
    responseJson = '{"success":true,"message":"Customer updated successfully"}';
  else;
    responseJson = '{"success":false,"error":"Update failed","sqlcode":' + %char(sqlcode) + '}';
  endif;
  
  return responseJson;
end-proc;

// JSON値抽出ユーティリティ
dcl-proc extractJsonValue;
  dcl-pi *n varchar(200);
    jsonString varchar(1000) const;
    key varchar(50) const;
  end-pi;
  
  dcl-s startPos int(10);
  dcl-s endPos int(10);
  dcl-s searchPattern varchar(60);
  dcl-s value varchar(200);
  
  searchPattern = '"' + %trim(key) + '":"';
  startPos = %scan(searchPattern : jsonString);
  
  if startPos > 0;
    startPos += %len(searchPattern);
    endPos = %scan('"' : jsonString : startPos);
    if endPos > startPos;
      value = %subst(jsonString : startPos : endPos - startPos);
    endif;
  endif;
  
  return value;
end-proc;
```

**OpenAPI仕様書の生成**

API の仕様を明確にするため、OpenAPI（Swagger）仕様書を作成します。

```yaml
openapi: 3.0.0
info:
  title: Customer Management API
  description: IBM i Customer Management System API
  version: 1.0.0
  contact:
    name: API Support
    email: api-support@company.com

servers:
  - url: https://ibmi-server.company.com/api/v1
    description: Production server

paths:
  /customers/{customerId}:
    get:
      summary: Get customer information
      description: Retrieve detailed information for a specific customer
      parameters:
        - name: customerId
          in: path
          required: true
          schema:
            type: integer
            format: int32
          description: Unique customer identifier
      responses:
        '200':
          description: Customer information retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Customer'
        '404':
          description: Customer not found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    
    put:
      summary: Update customer information
      description: Update existing customer information
      parameters:
        - name: customerId
          in: path
          required: true
          schema:
            type: integer
            format: int32
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CustomerUpdate'
      responses:
        '200':
          description: Customer updated successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SuccessResponse'
        '400':
          description: Invalid input data
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'

components:
  schemas:
    Customer:
      type: object
      properties:
        customerId:
          type: integer
          format: int32
          description: Unique customer identifier
        name:
          type: string
          maxLength: 50
          description: Customer full name
        email:
          type: string
          format: email
          maxLength: 100
          description: Customer email address
        phone:
          type: string
          maxLength: 20
          description: Customer phone number
        address:
          type: string
          maxLength: 200
          description: Customer address
        status:
          type: string
          enum: [A, I, S]
          description: Customer status (A=Active, I=Inactive, S=Suspended)
        lastUpdated:
          type: string
          format: date-time
          description: Last update timestamp
    
    CustomerUpdate:
      type: object
      required:
        - name
        - email
      properties:
        name:
          type: string
          maxLength: 50
        email:
          type: string
          format: email
          maxLength: 100
        phone:
          type: string
          maxLength: 20
        address:
          type: string
          maxLength: 200
    
    SuccessResponse:
      type: object
      properties:
        success:
          type: boolean
        message:
          type: string
    
    Error:
      type: object
      properties:
        error:
          type: string
        code:
          type: integer
        details:
          type: string

  securitySchemes:
    ApiKeyAuth:
      type: apiKey
      in: header
      name: X-API-Key

security:
  - ApiKeyAuth: []
```

### 10.2 外部API の利用

IBM iシステムから外部のWeb APIを利用することで、システムの機能を大幅に拡張できます。

**HTTP クライアントの実装**

```rpg
**FREE
ctl-opt dftactgrp(*no) actgrp(*caller);

// HTTP GET リクエスト
dcl-proc httpGet export;
  dcl-pi *n varchar(32000);
    url varchar(500) const;
    headers varchar(1000) const options(*nopass);
  end-pi;
  
  dcl-s response varchar(32000);
  dcl-s curlCommand varchar(1000);
  dcl-s tempFile varchar(100);
  
  // 一時ファイル名の生成
  tempFile = '/tmp/http_response_' + %char(%timestamp()) + '.txt';
  
  // cURLコマンドの構築
  curlCommand = 'curl -s -o ' + tempFile + ' "' + url + '"';
  
  if %parms() >= 2 and headers <> '';
    curlCommand += ' -H "' + headers + '"';
  endif;
  
  // cURLコマンドの実行
  system(curlCommand);
  
  // レスポンスファイルの読み込み
  response = readFile(tempFile);
  
  // 一時ファイルの削除
  system('rm ' + tempFile);
  
  return response;
end-proc;

// HTTP POST リクエスト
dcl-proc httpPost export;
  dcl-pi *n varchar(32000);
    url varchar(500) const;
    data varchar(32000) const;
    headers varchar(1000) const options(*nopass);
  end-pi;
  
  dcl-s response varchar(32000);
  dcl-s curlCommand varchar(1000);
  dcl-s dataFile varchar(100);
  dcl-s tempFile varchar(100);
  
  // データファイルの作成
  dataFile = '/tmp/post_data_' + %char(%timestamp()) + '.json';
  writeFile(dataFile : data);
  
  // レスポンスファイル名の生成
  tempFile = '/tmp/http_response_' + %char(%timestamp()) + '.txt';
  
  // cURLコマンドの構築
  curlCommand = 'curl -s -X POST -d @' + dataFile + ' -o ' + tempFile + ' "' + url + '"';
  
  if %parms() >= 3 and headers <> '';
    curlCommand += ' -H "' + headers + '"';
  endif;
  
  // cURLコマンドの実行
  system(curlCommand);
  
  // レスポンスファイルの読み込み
  response = readFile(tempFile);
  
  // 一時ファイルの削除
  system('rm ' + dataFile + ' ' + tempFile);
  
  return response;
end-proc;
```

**外部API利用の実例**

**天気情報API の利用**

```rpg
// 天気情報取得プログラム
dcl-proc getWeatherInfo export;
  dcl-pi *n varchar(1000);
    cityCode varchar(10) const;
  end-pi;
  
  dcl-s apiUrl varchar(200);
  dcl-s apiKey varchar(50);
  dcl-s response varchar(1000);
  dcl-s headers varchar(100);
  
  // API設定の取得
  apiKey = getConfigValue('WEATHER_API_KEY');
  apiUrl = 'https://api.openweathermap.org/data/2.5/weather?id=' + 
           cityCode + '&appid=' + apiKey + '&units=metric&lang=ja';
  
  headers = 'Content-Type: application/json';
  
  // API呼び出し
  response = httpGet(apiUrl : headers);
  
  return response;
end-proc;

// 天気情報の解析と表示
dcl-proc displayWeather export;
  dcl-pi *n;
    cityCode varchar(10) const;
  end-pi;
  
  dcl-s weatherJson varchar(1000);
  dcl-s cityName varchar(50);
  dcl-s temperature varchar(10);
  dcl-s description varchar(100);
  dcl-s humidity varchar(10);
  
  // 天気情報の取得
  weatherJson = getWeatherInfo(cityCode);
  
  // JSON解析
  cityName = extractJsonValue(weatherJson : 'name');
  temperature = extractJsonValue(weatherJson : 'main.temp');
  description = extractJsonValue(weatherJson : 'weather.0.description');
  humidity = extractJsonValue(weatherJson : 'main.humidity');
  
  // 結果の表示
  dsply ('都市: ' + cityName);
  dsply ('気温: ' + temperature + '°C');
  dsply ('天気: ' + description);
  dsply ('湿度: ' + humidity + '%');
end-proc;
```

**決済API の利用**

```rpg
// クレジットカード決済処理
dcl-proc processPayment export;
  dcl-pi *n varchar(500);
    amount packed(15: 2) const;
    cardNumber varchar(20) const;
    expiryMonth varchar(2) const;
    expiryYear varchar(4) const;
    cvv varchar(4) const;
    customerEmail varchar(100) const;
  end-pi;
  
  dcl-s paymentData varchar(1000);
  dcl-s apiUrl varchar(200);
  dcl-s apiKey varchar(100);
  dcl-s headers varchar(200);
  dcl-s response varchar(500);
  
  // 決済API設定
  apiUrl = 'https://api.stripe.com/v1/charges';
  apiKey = getConfigValue('STRIPE_SECRET_KEY');
  
  // 決済データの構築
  paymentData = '{'
    + '"amount":' + %char(amount * 100) + ','  // セント単位
    + '"currency":"jpy",'
    + '"source":{'
      + '"object":"card",'
      + '"number":"' + cardNumber + '",'
      + '"exp_month":"' + expiryMonth + '",'
      + '"exp_year":"' + expiryYear + '",'
      + '"cvc":"' + cvv + '"'
    + '},'
    + '"receipt_email":"' + customerEmail + '",'
    + '"description":"Order payment"'
    + '}';
  
  // HTTPヘッダーの設定
  headers = 'Authorization: Bearer ' + apiKey + CRLF +
            'Content-Type: application/json';
  
  // 決済API呼び出し
  response = httpPost(apiUrl : paymentData : headers);
  
  return response;
end-proc;
```

**Slack通知の送信**

```rpg
// Slack通知送信
dcl-proc sendSlackNotification export;
  dcl-pi *n;
    channel varchar(50) const;
    message varchar(500) const;
    username varchar(50) const options(*nopass);
  end-pi;
  
  dcl-s webhookUrl varchar(200);
  dcl-s slackData varchar(1000);
  dcl-s headers varchar(100);
  dcl-s response varchar(500);
  dcl-s displayName varchar(50);
  
  // Webhook URL の取得
  webhookUrl = getConfigValue('SLACK_WEBHOOK_URL');
  
  // ユーザー名の設定
  if %parms() >= 3;
    displayName = username;
  else;
    displayName = 'IBM i System';
  endif;
  
  // Slackメッセージの構築
  slackData = '{'
    + '"channel":"' + channel + '",'
    + '"username":"' + displayName + '",'
    + '"text":"' + message + '",'
    + '"icon_emoji":":computer:"'
    + '}';
  
  headers = 'Content-Type: application/json';
  
  // Slack API呼び出し
  response = httpPost(webhookUrl : slackData : headers);
end-proc;

// システムエラー通知
dcl-proc notifySystemError export;
  dcl-pi *n;
    errorMessage varchar(200) const;
    programName varchar(50) const;
    userId varchar(10) const;
  end-pi;
  
  dcl-s notificationMessage varchar(500);
  
  notificationMessage = ':warning: システムエラーが発生しました' + CRLF +
                       'プログラム: ' + programName + CRLF +
                       'ユーザー: ' + userId + CRLF +
                       'エラー内容: ' + errorMessage + CRLF +
                       '時刻: ' + %char(%timestamp());
  
  sendSlackNotification('#alerts' : notificationMessage : 'Error Bot');
end-proc;
```

### 10.3 メッセージキューとイベント駆動アーキテクチャ

現代的なシステム統合では、メッセージキューを使用したイベント駆動アーキテクチャが重要です。IBM iシステムでも、これらの技術を活用できます。

**IBM MQ との統合**

```rpg
// IBM MQ メッセージ送信
dcl-proc sendMQMessage export;
  dcl-pi *n;
    queueName varchar(50) const;
    message varchar(1000) const;
    correlationId varchar(24) const options(*nopass);
  end-pi;
  
  dcl-s mqCommand varchar(500);
  dcl-s messageFile varchar(100);
  dcl-s corrId varchar(24);
  
  // メッセージファイルの作成
  messageFile = '/tmp/mq_message_' + %char(%timestamp()) + '.txt';
  writeFile(messageFile : message);
  
  // 相関IDの設定
  if %parms() >= 3;
    corrId = correlationId;
  else;
    corrId = %char(%timestamp());
  endif;
  
  // MQコマンドの構築
  mqCommand = 'echo "' + message + '" | /opt/mqm/bin/amqsput ' + queueName;
  
  // メッセージ送信
  system(mqCommand);
  
  // 一時ファイルの削除
  system('rm ' + messageFile);
end-proc;

// IBM MQ メッセージ受信
dcl-proc receiveMQMessage export;
  dcl-pi *n varchar(1000);
    queueName varchar(50) const;
    waitTime int(10) const options(*nopass);
  end-pi;
  
  dcl-s mqCommand varchar(200);
  dcl-s outputFile varchar(100);
  dcl-s message varchar(1000);
  dcl-s timeout int(10);
  
  // タイムアウトの設定
  if %parms() >= 2;
    timeout = waitTime;
  else;
    timeout = 30;  // デフォルト30秒
  endif;
  
  // 出力ファイル名の生成
  outputFile = '/tmp/mq_output_' + %char(%timestamp()) + '.txt';
  
  // MQコマンドの構築
  mqCommand = '/opt/mqm/bin/amqsget ' + queueName + ' > ' + outputFile;
  
  // メッセージ受信
  system(mqCommand);
  
  // メッセージファイルの読み込み
  message = readFile(outputFile);
  
  // 一時ファイルの削除
  system('rm ' + outputFile);
  
  return message;
end-proc;
```

**Apache Kafka との統合**

```rpg
// Kafka プロデューサー
dcl-proc publishToKafka export;
  dcl-pi *n;
    topic varchar(50) const;
    key varchar(100) const;
    value varchar(1000) const;
  end-pi;
  
  dcl-s kafkaCommand varchar(500);
  dcl-s messageFile varchar(100);
  dcl-s kafkaConfig varchar(200);
  
  // Kafka設定の取得
  kafkaConfig = getConfigValue('KAFKA_BOOTSTRAP_SERVERS');
  
  // メッセージファイルの作成
  messageFile = '/tmp/kafka_message_' + %char(%timestamp()) + '.json';
  writeFile(messageFile : value);
  
  // Kafkaコマンドの構築
  kafkaCommand = '/opt/kafka/bin/kafka-console-producer.sh ' +
                 '--bootstrap-server ' + kafkaConfig + ' ' +
                 '--topic ' + topic + ' ' +
                 '--property "key.separator=:" ' +
                 '--property "parse.key=true" < ' + messageFile;
  
  // メッセージ送信
  system(kafkaCommand);
  
  // 一時ファイルの削除
  system('rm ' + messageFile);
end-proc;

// イベント発行の例
dcl-proc publishOrderEvent export;
  dcl-pi *n;
    eventType varchar(50) const;
    orderNo packed(10: 0) const;
    customerId packed(7: 0) const;
    amount packed(15: 2) const;
  end-pi;
  
  dcl-s eventData varchar(1000);
  dcl-s eventKey varchar(100);
  
  // イベントキーの生成
  eventKey = 'order:' + %char(orderNo);
  
  // イベントデータの構築
  eventData = '{'
    + '"eventType":"' + eventType + '",'
    + '"eventId":"' + %char(%timestamp()) + '",'
    + '"timestamp":"' + %char(%timestamp()) + '",'
    + '"data":{'
      + '"orderNo":' + %char(orderNo) + ','
      + '"customerId":' + %char(customerId) + ','
      + '"amount":' + %char(amount)
    + '}'
    + '}';
  
  // Kafkaに発行
  publishToKafka('order.events' : eventKey : eventData);
end-proc;
```

**Redis との統合**

```rpg
// Redis キャッシュ操作
dcl-proc setRedisCache export;
  dcl-pi *n;
    key varchar(100) const;
    value varchar(1000) const;
    expireSeconds int(10) const options(*nopass);
  end-pi;
  
  dcl-s redisCommand varchar(500);
  dcl-s redisServer varchar(100);
  dcl-s expire int(10);
  
  // Redis設定の取得
  redisServer = getConfigValue('REDIS_SERVER');
  
  // 有効期限の設定
  if %parms() >= 3;
    expire = expireSeconds;
  else;
    expire = 3600;  // デフォルト1時間
  endif;
  
  // Redisコマンドの構築
  redisCommand = 'redis-cli -h ' + redisServer + 
                 ' SETEX "' + key + '" ' + %char(expire) + ' "' + value + '"';
  
  // Redis実行
  system(redisCommand);
end-proc;

dcl-proc getRedisCache export;
  dcl-pi *n varchar(1000);
    key varchar(100) const;
  end-pi;
  
  dcl-s redisCommand varchar(300);
  dcl-s redisServer varchar(100);
  dcl-s outputFile varchar(100);
  dcl-s value varchar(1000);
  
  // Redis設定の取得
  redisServer = getConfigValue('REDIS_SERVER');
  
  // 出力ファイル名の生成
  outputFile = '/tmp/redis_output_' + %char(%timestamp()) + '.txt';
  
  // Redisコマンドの構築
  redisCommand = 'redis-cli -h ' + redisServer + ' GET "' + key + '" > ' + outputFile;
  
  // Redis実行
  system(redisCommand);
  
  // 結果の読み込み
  value = readFile(outputFile);
  
  // 一時ファイルの削除
  system('rm ' + outputFile);
  
  return value;
end-proc;
```

これらの技術を活用することで、IBM iシステムを現代的なアーキテクチャに統合し、スケーラブルで保守性の高いシステムを構築できます。Web系エンジニアの方にとって、既存の知識を活かしながらIBM iの世界を拡張していく道筋が見えてくるでしょう。


---

# まとめと今後の学習

## 学習ロードマップ

このチュートリアルを通じて、Web系エンジニアの方がIBM i（AS400）の世界に入門するための基礎知識から応用技術まで学習してきました。ここでは、今後の学習を効率的に進めるためのロードマップを提示します。

### 初級レベル（1-3ヶ月）

**目標**: IBM iの基本概念を理解し、簡単な操作ができるようになる

**学習項目**:
1. PUB400.comでの実習環境構築
2. 5250エミュレータの基本操作
3. ライブラリとオブジェクトの概念理解
4. 基本的なCLコマンドの習得
5. SQLによるデータベース操作

**実践課題**:
- 自分専用のライブラリを作成し、基本的なファイル操作を実行
- 簡単なSQLクエリでデータの検索・更新を実行
- 基本的なCLプログラムを作成して実行

### 中級レベル（3-6ヶ月）

**目標**: RPGプログラミングの基礎を習得し、簡単なビジネスアプリケーションを作成できるようになる

**学習項目**:
1. RPG言語の基本構文
2. 埋め込みSQLの活用
3. ファイル処理とレコード操作
4. エラーハンドリングとデバッグ技法
5. プロシージャとモジュールの概念

**実践課題**:
- 顧客管理システムの簡単なCRUD操作を実装
- データベースとの連携を含むバッチ処理プログラムを作成
- エラーハンドリングを含む堅牢なプログラムを作成

### 上級レベル（6-12ヶ月）

**目標**: 現代的な開発手法を取り入れ、外部システムとの連携ができるようになる

**学習項目**:
1. VS Code + Code for IBM iによる現代的な開発環境
2. Gitを使用したバージョン管理
3. RESTful APIの作成と公開
4. 外部APIとの連携
5. CI/CDパイプラインの構築

**実践課題**:
- 既存のRPGプログラムをWebサービス化
- 外部のクラウドサービスとの連携システムを構築
- 自動化されたビルド・デプロイパイプラインを構築

### エキスパートレベル（12ヶ月以上）

**目標**: レガシーシステムのモダン化を主導し、アーキテクチャ設計ができるようになる

**学習項目**:
1. マイクロサービスアーキテクチャの設計
2. クラウドネイティブな統合パターン
3. パフォーマンス最適化とチューニング
4. セキュリティ設計とコンプライアンス
5. チーム開発とプロジェクト管理

**実践課題**:
- レガシーシステムのモダン化プロジェクトを設計・実行
- 大規模なシステム統合プロジェクトを主導
- 新しい技術の導入と評価を実施

## 継続学習のためのリソース

### 公式ドキュメント

**IBM i Knowledge Center**
IBM iの公式ドキュメントです。最新の機能や詳細な技術情報が掲載されています。
https://www.ibm.com/docs/en/i

**IBM Developer**
IBM iに関する技術記事、チュートリアル、サンプルコードが豊富に提供されています。
https://developer.ibm.com/technologies/systems/

### コミュニティとフォーラム

**IBM i Community**
IBM i開発者のためのコミュニティサイトです。質問や議論、最新情報の共有が行われています。

**COMMON**
IBM iユーザーグループの国際組織です。カンファレンスやセミナーが定期的に開催されています。
https://www.common.org/

**Reddit r/IBMi**
IBM iに関するRedditコミュニティです。カジュアルな質問や情報交換が行われています。

### 学習プラットフォーム

**IBM SkillsBuild**
IBMが提供する無料の学習プラットフォームです。IBM iに関するコースも提供されています。

**Coursera IBM Courses**
IBM iやエンタープライズシステムに関する大学レベルのコースが提供されています。

### 書籍

**「IBM i (AS/400) プログラミング入門」**
日本語で書かれたIBM i入門書です。基礎から応用まで体系的に学習できます。

**「Modern RPG Language Reference」**
最新のRPG言語仕様について詳しく解説された英語の技術書です。

**「IBM i Modernization」**
IBM iシステムのモダン化について包括的に解説された書籍です。

### 実習環境

**PUB400.com**
このチュートリアルでも紹介した無料のIBM i学習環境です。継続的な学習に最適です。
http://www.pub400.com/

**IBM Cloud**
IBM iのクラウド版を試用できます。本格的な開発環境として利用可能です。

**IBM Power Systems Virtual Server**
クラウド上でIBM iを利用できるサービスです。商用レベルの環境を体験できます。

## キャリアパスと認定資格

### IBM i関連の認定資格

**IBM Certified System Administrator - IBM i**
IBM iシステム管理者向けの認定資格です。システム運用・管理のスキルを証明できます。

**IBM Certified Application Developer - IBM i**
IBM iアプリケーション開発者向けの認定資格です。RPGやCOBOLでの開発スキルを証明できます。

### キャリアパス

**システム管理者**
IBM iシステムの運用・管理を担当します。インフラエンジニアとしてのスキルを活かせます。

**アプリケーション開発者**
RPGやCOBOLでのビジネスアプリケーション開発を担当します。

**モダン化アーキテクト**
レガシーシステムのモダン化を設計・主導します。Web系の知識とIBM iの知識を組み合わせた高度な役割です。

**統合エンジニア**
IBM iと他のシステムとの連携を設計・実装します。API設計やクラウド統合のスキルが重要です。

## 最後に

このチュートリアルでは、Web系エンジニアの方がIBM i（AS400）の世界に入門するための包括的な内容を提供しました。IBM iは、一見古い技術に見えるかもしれませんが、実際には現代的な機能を多数備えた強力なプラットフォームです。

特に重要なのは、IBM iが単なるレガシーシステムではなく、現在も活発に開発が続けられ、新しい技術との統合も積極的に進められているということです。Web系エンジニアの方が持つモダンな開発手法や技術的知見は、IBM iの世界でも大いに活用できます。

IBM iの学習は、以下のような価値をもたらします：

**技術的な幅の拡大**: エンタープライズシステムの深い理解により、技術者としての幅が大きく広がります。

**キャリアの差別化**: Web系エンジニアでありながらIBM iも扱えるという希少性により、キャリア上の大きなアドバンテージとなります。

**ビジネス価値の理解**: 基幹システムの重要性と複雑さを理解することで、ビジネスにより大きな価値を提供できるようになります。

**レガシーモダン化の専門性**: 多くの企業が抱えるレガシーシステムのモダン化において、貴重な専門性を発揮できます。

IBM iの世界は奥が深く、学習すべきことは多岐にわたりますが、このチュートリアルが皆様の学習の出発点となり、新しい技術領域での成功につながることを願っています。

継続的な学習と実践を通じて、Web系エンジニアとしての知識とIBM iの専門性を組み合わせた、ユニークで価値の高い技術者として成長していってください。

---

# 参考資料

## 公式リソース

[1] IBM i Knowledge Center  
https://www.ibm.com/docs/en/i

[2] IBM Developer - IBM i  
https://developer.ibm.com/technologies/systems/

[3] IBM i Access Client Solutions  
https://www.ibm.com/support/pages/ibm-i-access-client-solutions

[4] Code for IBM i (VS Code Extension)  
https://marketplace.visualstudio.com/items?itemName=HalcyonTechLtd.code-for-ibmi

[5] Rational Developer for i (RDi)  
https://www.ibm.com/products/rational-developer-for-i

## 学習リソース

[6] PUB400.com - Free IBM i Access  
http://www.pub400.com/

[7] IBM i Magazine  
https://www.imagazine.co.jp/

[8] COMMON - IBM i User Group  
https://www.common.org/

[9] IBM SkillsBuild  
https://skillsbuild.org/

[10] IBM i入門ガイド  
https://www.imagazine.co.jp/imagazine-7071/

## 技術ドキュメント

[11] RPG Language Reference  
https://www.ibm.com/docs/en/i/7.4?topic=languages-rpg

[12] SQL Reference for IBM i  
https://www.ibm.com/docs/en/i/7.4?topic=languages-sql

[13] Control Language (CL) Reference  
https://www.ibm.com/docs/en/i/7.4?topic=languages-control-language

[14] IBM i Integrated Web Services  
https://www.ibm.com/docs/en/i/7.4?topic=services-integrated-web

[15] DB2 for i SQL Reference  
https://www.ibm.com/docs/en/i/7.4?topic=reference-sql

## コミュニティとフォーラム

[16] IBM i Community Forums  
https://community.ibm.com/community/user/power/communities/community-home?CommunityKey=61e1e4c2-9a47-4c2a-8131-7ac0d8e4b3a5

[17] Reddit r/IBMi  
https://www.reddit.com/r/IBMi/

[18] Stack Overflow - IBM i Tag  
https://stackoverflow.com/questions/tagged/ibm-midrange

## ツールとソフトウェア

[19] TN5250J Terminal Emulator  
http://tn5250j.org/

[20] IBM i Access for Windows  
https://www.ibm.com/support/pages/ibm-i-access-windows

[21] Git for IBM i  
https://github.com/IBM/git-for-ibmi

## クラウドサービス

[22] IBM Cloud - Power Systems Virtual Server  
https://cloud.ibm.com/power/overview

[23] IBM i on Cloud  
https://www.ibm.com/cloud/power-virtual-server

---

**著者**: Manus AI  
**作成日**: 2025年6月28日  
**バージョン**: 1.0

このチュートリアルは、Web系エンジニアの方がIBM i（AS400）を効率的に学習できるよう、実践的な内容を重視して作成されました。継続的な更新と改善を予定しており、読者の皆様からのフィードバックをお待ちしています。
